<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>PointFree Episode 83:Testable State Management: Effects | Kayouyou&#39;s Den</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://kayouyou.github.io/favicon.ico?v=1663232760640">
<link rel="stylesheet" href="https://kayouyou.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="



Recap: the environment




Controlling the favorite primes save effect




Controlling the favorite primes load effe..." />
    <meta name="keywords" content="PointFree" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://kayouyou.github.io">
        <img src="https://kayouyou.github.io/images/avatar.png?v=1663232760640" class="site-logo">
        <h1 class="site-title">Kayouyou&#39;s Den</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      The wise build bridges, while the foolish build barriers.
    </div>
    <div class="site-footer">
      豫ICP备2021012281号-1  | <a class="rss" href="https://kayouyou.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">PointFree Episode 83:Testable State Management: Effects</h2>
            <div class="post-date">2021-11-28</div>
            
            <div class="post-content" v-pre>
              <!-- vscode-markdown-toc -->
<ul>
<li>
<ol>
<li><a href="#Recap:theenvironment">Recap: the environment</a></li>
</ol>
</li>
<li>
<ol start="2">
<li><a href="#Controllingthefavoriteprimessaveeffect">Controlling the favorite primes save effect</a></li>
</ol>
</li>
<li>
<ol start="3">
<li><a href="#Controllingthefavoriteprimesloadeffect">Controlling the favorite primes load effect</a></li>
</ol>
</li>
<li>
<ol start="4">
<li><a href="#Testingthefavoriteprimessaveeffect">Testing the favorite primes save effect</a></li>
</ol>
</li>
<li>
<ol start="5">
<li><a href="#Testingthefavoriteprimesloadeffect">Testing the favorite primes load effect</a></li>
</ol>
</li>
<li>
<ol start="6">
<li><a href="#Controllingthecountereffect">Controlling the counter effect</a></li>
</ol>
</li>
<li>
<ol start="7">
<li><a href="#Testingthecountereffects">Testing the counter effects</a></li>
</ol>
</li>
<li>
<ol start="8">
<li><a href="#Nexttime:testergonomics">Next time: test ergonomics</a></li>
</ol>
</li>
</ul>
<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->
<!-- # PointFree Episode 83:Testable State Management: Effects -->
<h2 id="1-a-namerecaptheenvironmentarecap-the-environment">1. <a name='Recap:theenvironment'></a>Recap: the environment</h2>
<p>简而言之，<strong>environment</strong>允许我们将应用程序的所有依赖项与可变字段捆绑在一个单一的数据类型中，这使得将<strong>mock</strong>实现转换为<strong>live</strong>实现非常容易，反之亦然。这让我们能够在代码中测试所有的边缘情况和不愉快的路径，这不仅对于编写测试非常有用，而且对于在<strong>playgrounds</strong>中运行代码也非常有用。</p>
<p>我们将尝试<strong>environment</strong>理念来控制应用程序中的副作用。我们将从收藏素数屏幕开始，它具有最简单的保存和加载收藏素数的<strong>effects</strong>。我们将引入一个<strong>environment</strong>结构体，它最终将包含我们这个模块所需的所有副作用依赖项:</p>
<pre><code class="language-swift">struct Environment {
}
</code></pre>
<p>为了让我们回忆一下如何将依赖项添加到这个<strong>environment</strong>中，假设这个模块需要访问当前日期。这肯定是一个副作用，因为每次创建日期时时间都会改变。但是，我们不允许自己直接从代码中调用日期初始化器，而是将它添加到我们的<strong>environment</strong>中:</p>
<pre><code class="language-swift">struct Environment {
  var date: () -&gt; Date
}
</code></pre>
<p>此外，我们还可以使用这些依赖项的默认实时实现来扩展环境。</p>
<pre><code class="language-swift">extension Environment {
  static let live = Environment(
    date: Date.init
  )
}
</code></pre>
<p>然后我们在模块中有一个全局<strong>environment</strong>，所以任何时候我们想要访问日期，我们只访问当前<strong>environment</strong>中的日期:</p>
<pre><code class="language-swift">var Current = Environment()
</code></pre>
<p>这意味着，当我们想要获得一个日期值时，我们应该强制自己通过<strong>Current environment</strong>，而不是允许自己接触到不受控制的日期初始化器。</p>
<pre><code class="language-swift">Current.date()
</code></pre>
<p>因为这是一个可变属性，我们可以以一种更可控的方式交换我们的实现。例如，我们可以创建一个<strong>mock</strong>版本的环境，其中只有date函数总是返回相同的日期:</p>
<pre><code class="language-swift">extension Environment {
  static let mock = Environment(
    date: { Date(timeIntervalSince1970: 1234567890) }
  )
}
</code></pre>
<p>然后在测试中，我们将用<strong>mock</strong>环境来替换我们的<strong>live</strong>环境:</p>
<pre><code class="language-swift">Current = .mock
</code></pre>
<p>这允许我们在需要的时候以一种轻量级的方式控制这种依赖关系，比如在<strong>tests</strong>和<strong>playgrounds</strong>上，而生产应用程序将使用这些依赖关系的<strong>live</strong>版本。</p>
<p>日期依赖非常简单，但在<a href="https://www.pointfree.co/episodes/ep16-dependency-injection-made-easy">依赖注入</a>那一集中，我们还展示了一个更复杂的依赖:一个<strong>GitHub API</strong>客户端:</p>
<pre><code class="language-swift">struct GitHubClient {
  var fetchRepos: (@escaping (Result&lt;[Repo], Error&gt;) -&gt; Void) -&gt; Void

  struct Repo: Decodable {
    var archived: Bool
    var description: String?
    var htmlUrl: URL
    var name: String
    var pushedAt: Date?
  }
}
</code></pre>
<p>同样，它被表示为带有一些可变字段的简单结构体，因此我们可以轻松地将实现替换为<strong>mock</strong>。</p>
<p>我们完全理解这些代码可能会让我们的一些观众感到不舒服。首先，我们有一个标识符大写的变量。另一方面我们有一个可变的全局变量。然而，这些依赖项只能在<strong>playgrounds and tests</strong>中交换。在生产应用程序中，依赖项应该在环境中创建，然后不受影响。您甚至可以创建<strong>lint</strong>规则，以确保不会在<strong>playground or test</strong>之外修改环境。您还可以利用<strong>Environment</strong>是一种值类型这一事实，并强制它在生产中完全不可变:</p>
<pre><code class="language-swift">#if DEBUG
var Current = Environment()
#else
let Current = Environment()
#endif
</code></pre>
<p>简而言之，这就是<strong>environment</strong>!</p>
<ul>
<li>你创建一个名为<strong>Environment</strong>的结构体，其中包含一堆描述应用程序依赖关系的可变字段。</li>
<li>您创建了一个指向所有依赖项的<strong>live</strong>版本的<strong>live</strong>版本。</li>
<li>您可以创建一个<strong>mock</strong>版本，使用简单的、受控制的默认值将这些不同的端点存根出来。</li>
<li>然后在您的<strong>tests and playgrounds</strong>上，您可以使用<strong>mock</strong>版本并进一步交换其他<strong>mock</strong>场景，而在您的应用程序中，您将使用<strong>live</strong>版本。</li>
</ul>
<p>如果您仍然对此感到不舒服，我们强烈建议您观看关于这个主题的第16集，希望我们能让您相信这种类型的依赖项管理有很多好处，并极大地降低了现有解决方案的样板和复杂性。</p>
<p>现在让我们尝试<strong>live</strong>环境来控制应用程序的<strong>effects</strong>。</p>
<h2 id="2-a-namecontrollingthefavoriteprimessaveeffectacontrolling-the-favorite-primes-save-effect">2. <a name='Controllingthefavoriteprimessaveeffect'></a>Controlling the favorite primes save effect</h2>
<p>现在我们已经记住了<strong>environment</strong>是如何工作的，让我们创建一个<strong>environment</strong>来控制这个模块中的保存和加载效果。它们目前是小的私有助手，将有效逻辑包装在<strong>Effect</strong>类型中:</p>
<pre><code class="language-swift">private func saveEffect(favoritePrimes: [Int]) -&gt; Effect&lt;FavoritePrimesAction&gt; {
  return .fireAndForget {
    let data = try! JSONEncoder().encode(favoritePrimes)
    let documentsPath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)[0]
    let documentsUrl = URL(fileURLWithPath: documentsPath)
    let favoritePrimesUrl = documentsUrl.appendingPathComponent(&quot;favorite-primes.json&quot;)
    try! data.write(to: favoritePrimesUrl)
  }
}

private let loadEffect = Effect&lt;FavoritePrimesAction&gt;.sync {
  let documentsPath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)[0]
  let documentsUrl = URL(fileURLWithPath: documentsPath)
  let favoritePrimesUrl = documentsUrl.appendingPathComponent(&quot;favorite-primes.json&quot;)
  guard
    let data = try? Data(contentsOf: favoritePrimesUrl),
    let favoritePrimes = try? JSONDecoder().decode([Int].self, from: data)
    else { return nil }
  return .loadedFavoritePrimes(favoritePrimes)
}
.eraseToEffect()
</code></pre>
<p>这些<strong>effects</strong>的<strong>live</strong>实现会从<strong>reducer</strong>返回:</p>
<pre><code class="language-swift">case .saveButtonTapped:
  return [saveEffect(favoritePrimes: state)]

case .loadButtonTapped:
  return [loadEffect]
</code></pre>
<p>我们想要在一个可以放到环境中的依赖项中捕捉这些<strong>effects</strong>。让我们为喜爱的素数模块引入一个全新的<strong>environment</strong>。</p>
<pre><code class="language-swift">struct FavoritePrimesEnvironment {

}
</code></pre>
<p>这里是什么? 我们可以将<strong>save和load</strong>效果的字段直接添加到这个结构体中，但因为它们是相关的，所以我们从<strong>GitHubClient</strong>中获得一些灵感，创建一个<strong>FileClient</strong>来保存保存和加载的<strong>effects</strong>:</p>
<pre><code class="language-swift">struct FileClient {
}
</code></pre>
<p>每个<strong>effect</strong>都是这个结构体中的一个字段:</p>
<pre><code class="language-swift">struct FileClient {
//  var load:
//  var save:
}
</code></pre>
<p>让我们从<strong>load effect</strong>开始。在它的核心，所有的加载都涉及到生成一个表示最喜欢的质数的整数数组，所以我们可能会尝试做以下事情:</p>
<pre><code class="language-swift">struct FileClient {
  var load: () -&gt; [Int]?
//  var save:
}
</code></pre>
<p>这里有两个问题:</p>
<ul>
<li>首先，类型没有给出任何会发生影响的迹象。如果我们调用这个，我们知道它将访问磁盘上的数据，我们希望用类型表示。</li>
<li>其次，这种<strong>effect</strong>非常特定于我们的一个用例，即从名为<strong>favorite-prime .json</strong>的文件中加载一个整数数组。我们可以通用化，传入一个文件名，然后得到<strong>Data</strong>，然后我们可以自己解码<strong>JSON</strong>。</li>
</ul>
<p>解决这些问题很容易。我们可以首先为文件名引入一个<strong>String</strong>参数，然后泛化可选数据返回的可选整数数组。</p>
<pre><code class="language-swift">struct FileClient {
  var load: (String) -&gt; Effect&lt;Data?&gt;
//  var save:
}
</code></pre>
<p>可以以类似的方式处理<strong>save</strong>字段，但它可以接受要保存的文件的名称以及需要保存的数据。它还需要返回一个<strong>effect</strong>，但还不清楚什么<strong>effect</strong>应该是通用的:</p>
<pre><code class="language-swift">var save: (String, Data) -&gt; Effect&lt;???&gt;
</code></pre>
<p>记住，这是一种“<strong>fire-and-forget</strong>”的<strong>effect</strong>。它只需要将一些数据保存到磁盘，而不需要将任何数据发送回系统。我们可以做的一件事是将<strong>FavoritePrimesAction</strong>硬编码成这样的<strong>effect</strong>:</p>
<pre><code class="language-swift">var save: (String, Data) -&gt; Effect&lt;FavoritePrimesAction&gt;
</code></pre>
<p>然而，这不必要地将这个文件客户端直接耦合到这个模块。它阻止我们在某一天将这个客户端提取到它自己的模块中，并在其他屏幕或应用程序中使用它，而这些屏幕或应用程序并不关心这个最喜欢的prime屏幕。</p>
<p>我们可以通过使<strong>FileClient</strong>泛型来从<strong>FileClient</strong>中解耦<strong>effect</strong>的类型。这将允许任何人使用文件客户端自带自己的类型:</p>
<pre><code class="language-swift">struct FileClient&lt;Action&gt; {
  // …
  var save: (String, Data) -&gt; Effect&lt;A&gt;
}
</code></pre>
<p>但这似乎很重要，我们甚至不想让<strong>save effect</strong>能够产生反馈到系统的动作。</p>
<p>我们甚至可能会尝试使用<strong>Void</strong>作为效果的类型，因为它代表了一段没有语义或意义的数据:</p>
<pre><code class="language-swift">struct FileClient {
  // …
  var save: (String, Data) -&gt; Effect&lt;Void&gt;
}
</code></pre>
<p>这仍然是不对的，因为这将允许<strong>save effect</strong>发送一个空值回系统。</p>
<p>我们正在探索的所有这些错误的开始都指向了一些非常重要的东西。我们想在这种<strong>effect</strong>的类型中表现一些非常具体的东西。我们想要一种<strong>effect</strong>，它能正常工作，但不能产生值。它应该没有能力将操作发送回<strong>store</strong>。</p>
<p>有一种类型可以让我们做到这一点:<strong>Never</strong>。</p>
<pre><code class="language-swift">var save: (String, Data) -&gt; Effect&lt;Never&gt;
</code></pre>
<p>从不是所谓的“无人居住”类型。它是一个在Swift标准库中定义的<strong>zero cases</strong>的<strong>enum</strong>，。</p>
<pre><code class="language-swift">public enum Never {
}
</code></pre>
<p>构造<strong>Never</strong>类型的值是不可能的。 因为不可能构造一个值，所以这个<strong>effect</strong>发布者也不可能产生一个<strong>Never</strong>类型的排放。这是对我们想要此<strong>effect</strong>满足的属性的编译时验证。</p>
<p>这也为我们的api提供了非常好的文档。如果您曾经遇到过**Effect<Never>**类型，您甚至不用查看实现就知道它永远不会产生值，因此它一定是一种“<strong>fire-and-forget</strong>”<strong>effect</strong>。</p>
<p>现在我们已经将依赖项描述为一个简单的数据类型，我们可以创建它的活动版本用于生产。我们可以将它定义为<strong>FileClient</strong>类型的静态变量:</p>
<pre><code class="language-swift">extension FileClient {
  static let live = Self(
    load: &lt;#(String) -&gt; Effect&lt;Data?&gt;#&gt;,
    save: &lt;#(String, Data) -&gt; Effect&lt;Never&gt;#&gt;
  )
}
</code></pre>
<p>我们基本上可以将当前的<strong>effect</strong>复制粘贴到这些闭包中，只做最小的更改:</p>
<pre><code class="language-swift">extension FileClient {
  static let live = Self(
    load: { fileName in
      .sync {
        let documentsPath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)[0]
        let documentsUrl = URL(fileURLWithPath: documentsPath)
        let favoritePrimesUrl = documentsUrl.appendingPathComponent(fileName)
        return try? Data(contentsOf: favoritePrimesUrl)
      }
  },
    save: { fileName, data in
      .fireAndForget {
        let documentsPath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)[0]
        let documentsUrl = URL(fileURLWithPath: documentsPath)
        let favoritePrimesUrl = documentsUrl.appendingPathComponent(fileName)
        try! data.write(to: favoritePrimesUrl)
      }
  })
}
</code></pre>
<p>现在我们可以将这个依赖添加到我们的<strong>environment</strong>中:</p>
<pre><code class="language-swift">struct FavoritePrimesEnvironment {
  var fileClient: FileClient
}
</code></pre>
<p>现在我们可以定义一个环境的<strong>live</strong>版本，它使用文件客户端的<strong>live</strong>实现:</p>
<pre><code class="language-swift">extension FavoritePrimesEnvironment {
  static let live = FavoritePrimesEnvironment(fileClient: .live)
}
</code></pre>
<p>最后，我们希望使用大写的<strong>Current</strong>实例化环境的一个<strong>live</strong>实例:</p>
<pre><code class="language-swift">var Current = FavoritePrimesEnvironment.live
</code></pre>
<p>环境就绪后，我们只需要重构我们的<strong>reducer</strong>，使其不再直接构造其<strong>effects</strong>，而只使用<strong>Current</strong>环境。</p>
<p>让我们从<strong>save effect</strong>开始:</p>
<pre><code class="language-swift">case .saveButtonTapped:
  return [saveEffect(favoritePrimes: state)]
</code></pre>
<p>我们可以在我们的环境中使用新的<strong>effect</strong>，而不是调用这个局部的私有<strong>effect</strong>:</p>
<pre><code class="language-swift">Current.fileClient.save
</code></pre>
<p>文件名和我们一直使用的文件名是一样的</p>
<pre><code class="language-swift">Current.fileClient
  .save(&quot;favorite-primes.json&quot;, ???)
</code></pre>
<p>要给出这个函数数据，我们必须在<strong>reducer</strong>中正确地执行JSON编码。这是一个非常好的做法，因为JSON编码是一个纯操作:</p>
<pre><code class="language-swift">Current.fileClient.save(&quot;favorite-primes.json&quot;, try! JSONEncoder().encode(state))
</code></pre>
<p>现在这个还不能编译，因为它返回一个<strong>Effect<Never></strong>，但我们需要返回一个<strong>Effect<FavoritePrimesAction></strong>。</p>
<blockquote>
<p>🛑 Cannot convert value of type ‘Effect’ to expected element type ‘Effect’</p>
</blockquote>
<p>我们刚才讨论了返回<strong>Effect<Never><strong>来表示</strong>fire-and-forget****effect</strong>是如何正确的，但现在它似乎给我们带来了问题。 我们究竟如何将<strong>Never</strong>值转换为<strong>FavoritePrimesAction</strong>值呢?</p>
<p>当然，这是完全可能的，我们在Point-Free的第9集讨论Swift的类型系统和代数之间的关系时讨论过。使用代数作为我们的指路明灯，我们能够发现下面的签名实际上有一个实现:</p>
<pre><code class="language-swift">// (Never) -&gt; A
</code></pre>
<p>We called it absurd, because it seems pretty absurd:</p>
<pre><code class="language-swift">func absurd&lt;A&gt;(_ never: Never) -&gt; A {
  switch never {}
}
</code></pre>
<p>这是因为我们的<strong>switch</strong>已经详尽地处理了<strong>Never</strong>中的每个<strong>case</strong>，这是完全正确的，因为<strong>Never</strong>没有<strong>case</strong>。</p>
<p>这是我们在本集的实现，但从那以后Swift变得更聪明了，我们现在甚至可以省略这个函数体:</p>
<pre><code class="language-swift">func absurd&lt;A&gt;(_ never: Never) -&gt; A {}
</code></pre>
<p>这正是我们可以使用的函数，将我们的“<strong>fire-and-forget effect</strong>”从“<strong>Nevers</strong>”的世界提升到“<strong>reducer</strong>”行动的世界:</p>
<pre><code class="language-swift">Current.fileClient.save(&quot;favorite-primes.json&quot;, try! JSONEncoder().encode(state))
  .map(absurd)
</code></pre>
<p>现在这无法编译，因为我们要确保将<strong>publisher</strong>类型擦除回<strong>effect</strong>类型</p>
<pre><code class="language-swift">Current.fileClient.save(&quot;favorite-primes.json&quot;, try! JSONEncoder().encode(state))
  .map(absurd)
  .eraseToEffect()
</code></pre>
<p>现在可以编译了。我们甚至可以将这个小小的<strong>absurd dance</strong>捆绑在一个自定义操作符中，这样我们就可以为它取一个好听的名字:</p>
<pre><code class="language-swift">extension Publisher where Output == Never, Failure == Never {
  func fireAndForget&lt;A&gt;() -&gt; Effect&lt;A&gt; {
    return self.map(absurd).eraseToEffect()
  }
}
</code></pre>
<p>And now we can simply do:</p>
<pre><code class="language-swift">Current.fileClient
  .save(&quot;favorite-primes.json&quot;, try! JSONEncoder().encode(state))
  .fireAndForget()
</code></pre>
<p>这读起来很不错。它清楚地说明了这是一种<strong>fire-and-forget effect</strong>，它允许我们向上投射<strong>Never</strong>类型到我们需要从这个<strong>reducer</strong>返回的任何类型。</p>
<p>现在我们可以删除之前的<strong>saveEffect</strong>了:</p>
<pre><code class="language-swift">//private func saveEffect(favoritePrimes: [Int]) -&gt; Effect&lt;FavoritePrimesAction&gt; {
//  return .fireAndForget {
//    let data = try! JSONEncoder().encode(favoritePrimes)
//    let documentsPath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)[0]
//    let documentsUrl = URL(fileURLWithPath: documentsPath)
//    let favoritePrimesUrl = documentsUrl.appendingPathComponent(&quot;favorite-primes.json&quot;)
//    try! data.write(to: favoritePrimesUrl)
//  }
//}
</code></pre>
<h2 id="3-a-namecontrollingthefavoriteprimesloadeffectacontrolling-the-favorite-primes-load-effect">3. <a name='Controllingthefavoriteprimesloadeffect'></a>Controlling the favorite primes load effect</h2>
<p>一个<strong>effect</strong>消失了，还有一个。我们能够将我们的<strong>effect</strong>提取到一个环境中，以便它们的<strong>live</strong>实现可以被替换为<strong>mock</strong>实现，但我们只处理了一个“<strong>fire-and-forget</strong>”的<strong>effect</strong>。</p>
<p>接下来，我们可以改变<strong>load effect</strong>来使用环境:</p>
<pre><code class="language-swift">case .loadButtonTapped:
  return [
    loadEffect
      .compactMap { $0 }
      .eraseToEffect()
  ]
</code></pre>
<p>我们可以从调用环境上的端点开始</p>
<pre><code class="language-swift">Current.fileClient.load(&quot;favorite-primes.json&quot;)
</code></pre>
<p>这就产生了<strong>Data?<strong>的</strong>effect</strong>。我们想要从<strong>JSON</strong>中解码这些内容，幸运的是，在<strong>Combine publishers</strong>上有一个帮手来做这件事:</p>
<pre><code class="language-swift">Current.fileClient.load(&quot;favorite-primes.json&quot;)
  .decode(type: [Int].self, decoder: JSONDecoder())
</code></pre>
<p>然而，这并不工作，因为<strong>decode</strong>期望一个诚实的数据的发布者，而我们给它可选的数据。</p>
<pre><code class="language-swift">Current.fileClient
  .load(&quot;favorite-primes.json&quot;)
  .compactMap { $0 }
  .decode(type: [Int].self, decoder: JSONDecoder())
</code></pre>
<p>从技术上讲，这给了我们一个可能会失败的发行商，因为从JSON解码的过程可能会失败。但是我们的<strong>Effect publisher</strong>是不允许失败的，因为我们必须直接在我们的<strong>reducer</strong>中显式地处理任何失败。</p>
<p>我们可以使用<strong>publishers</strong>上的<strong>catch</strong>方法来解决这个问题，它允许您拦截<strong>publishers</strong>产生的任何错误，并将其映射到一个全新的<strong>publisher</strong>。</p>
<pre><code class="language-swift">Current.fileClient
  .load(&quot;favorite-primes.json&quot;)
  .compactMap { $0 }
  .decode(type: [Int].self, decoder: JSONDecoder())
  .catch { _ in Empty(completeImmediately: true) }
</code></pre>
<p>现在我们有了一个简单的整数数组的<strong>publisher</strong>，所以我们要做的就是将它映射到<strong>FavoritePrimesAction</strong>中，并将<strong>publisher</strong>擦除到我们的<strong>effect</strong>类型:</p>
<pre><code class="language-swift">Current.fileClient
  .load(&quot;favorite-primes.json&quot;)
  .compactMap { $0 }
  .decode(type: [Int].self, decoder: JSONDecoder())
  .catch { _ in Empty(completeImmediately: true) }
  .map(FavoritePrimesAction.loadedFavoritePrimes)
  .eraseToEffect()
</code></pre>
<p>现在这个模块正在编译，就像刚才那样，我们已经控制了这个屏幕中的所有<strong>effects</strong>。我们甚至可以注释掉旧的、无法控制的<strong>load effect</strong>。任何可以执行副作用的东西都被填充到这个<strong>Environment</strong>类型中，它保存了生产应用程序的<strong>live</strong>实现，但也让我们在需要时方便地切换实现。</p>
<p>为了看到这一点，让我们创建一个<strong>mock</strong>版本与我们的<strong>live</strong>版本共存:</p>
<pre><code class="language-swift">extension FavoritePrimesEnvironment {
  static let mock = FavoritePrimesEnvironment(
    fileClient: FileClient(
      load: { _ in Effect&lt;Data?&gt;.sync { try! JSONEncoder().encode([2, 31])) } },
      save: { _, _ in .fireAndForget {} }
    )
  )
}
</code></pre>
<p>我们甚至可以在调试检查中保护这段代码，以便它只与应用的调试版本一起发布:</p>
<pre><code class="language-swift">#if DEBUG
// …
#endif
</code></pre>
<p>现在，我们有了一种超级简单的方法来将环境的<strong>live</strong>版本替换为<strong>mock</strong>版本。为了展示它的强大功能，让我们更新<strong>playground</strong>，使用<strong>mock</strong>环境，而不是实际访问文件系统:</p>
<pre><code class="language-swift">@testable import FavoritePrimes
// …

Current = .mock

PlaygroundPage.current.liveView = UIHostingController(
  rootView: NavigationView {
    FavoritePrimesView(
      store: Store&lt;[Int], FavoritePrimesAction&gt;(
        initialValue: [2, 3],
        reducer: favoritePrimesReducer
      )
    )
  }
)
</code></pre>
<p>如果我们运行<strong>playground</strong>并点击<strong>load</strong>，我们将看到质数2和31弹出，即使我们没有点击<strong>save</strong>。这是因为 <strong>mock load effect</strong>硬编码了要加载的启动数。我们甚至可以对这个应用程序进行压力测试，看看它是如何加载超大的质数列表的:</p>
<pre><code class="language-swift">Current = .mock
Current.fileClient.load = { _ in
  Effect.sync { try! JSONEncoder().encode(Array(1...100)) }
}
</code></pre>
<p>就像我们看到的，当我们试图加载100个数字到这个界面时，会发生什么。当然，它们不是质数，但这对我们现在要测试的东西并不重要。为了更清楚地说明这一点，让我们增大这个数组的大小，以容纳1000个整数:</p>
<pre><code class="language-swift">Current.fileClient.load = { _ in
  Effect.sync { try! JSONEncoder().encode(Array(1...1000)) }
}
</code></pre>
<p>现在，当我们在界面中点击加载时，我们看到它会冻结几秒钟，然后将更改动画到位。对于<strong>SwiftUI</strong>和非常大的列表来说，这似乎是一个问题，但是我们可以通过模拟<strong>effects</strong>轻松地对界面进行压力测试，而不需要找到将一个大的整数JSON文件放到磁盘上的方法，这是非常棒的。</p>
<h2 id="4-a-nametestingthefavoriteprimessaveeffectatesting-the-favorite-primes-save-effect">4. <a name='Testingthefavoriteprimessaveeffect'></a>Testing the favorite primes save effect</h2>
<p>现在我们已经具备了开始为<strong>effects</strong>编写一些测试所需的一切。让我们看看我们已经为<strong>favoritePrimesReducer</strong>编写了哪些测试:</p>
<pre><code class="language-swift">func testSaveButtonTapped() {
  var state = [2, 3, 5, 7]
  let effects = favoritePrimesReducer(state: &amp;state, action: .saveButtonTapped)
  XCTAssertEqual(state, [2, 3, 5, 7])
  XCTAssertEqual(effects.count, 1)
}
</code></pre>
<p>这是最简单的测试，即当我们点击保存按钮时，我们不会改变状态，但我们会发出一种<strong>effect</strong>。为了测试这个<strong>effect</strong>，我们可以运行它:</p>
<pre><code class="language-swift">_ = effects[0].sink { }
</code></pre>
<p>记住，默认情况下，我们使用的是这个<strong>effect</strong>的实时实现，这意味着要理解这个<strong>effect</strong>的作用，我们需要找到磁盘上的文件并断言保存了什么。正如我们之前提到的，这是一件非常脆弱的事情，因为我们甚至可能没有对这个磁盘的读写权限。我们希望完全消除处理实际磁盘存储的各种怪异操作，这可以通过使用<strong>mock</strong>环境来实现:</p>
<pre><code class="language-swift">Current = .mock
</code></pre>
<p>这样就不会碰到磁盘了。然而，这仍然不能帮助我们测试保存<strong>effect</strong>。我们真正想测试的是是否调用了保存<strong>effect</strong>。 我们必须相信，只要传递了正确的信息，实时保存<strong>effect</strong>就会做正确的事情。为了在模拟<strong>effect</strong>中捕捉到它，我们只需在周围保留一个可变的布尔值，指示是否执行了<strong>save</strong>效果，然后在<strong>effect</strong>中翻转它:</p>
<pre><code class="language-swift">var didSave = false
Current.fileClient.save = { _, _ in .fireAndForget { didSave = true } }
</code></pre>
<p>然后我们只想确保这个布尔值在执行<strong>effect</strong>后被翻转为<strong>true</strong>:</p>
<pre><code class="language-swift">_ = effects[0].sink { _ in }

XCTAssert(didSave)
</code></pre>
<p>如果我们运行测试，它通过了，这意味着我们已经断言<strong>reducer</strong>使用了我们期望的<strong>effect</strong>! 这意味着只要我们相信保存<strong>effect</strong>是正确的，这是一个非常简单的<strong>effect</strong>，所以我们也许可以相信它是正确的，那么我们至少可以得到一些关于这个<strong>effect</strong>的报道。</p>
<p>我们可以更进一步，确保这个<strong>effect</strong>的回调函数永远不会被调用，因为这个<strong>effect</strong>应该是“<strong>fire-and-forget</strong>”的:</p>
<pre><code class="language-swift">_ = effects[0].sink { _ in XCTFail() }
</code></pre>
<p>这很好，因为它保证我们已经捕获了这个<strong>effect</strong>的整个周期，也就是说，这个<strong>effect</strong>不会产生任何我们需要通过<strong>reducer</strong>来验证其行为是否符合预期的操作。</p>
<p>我们刚刚在这里取得的成就值得反思。只需要很少的设置，我们便能够以一种非常直接的方式确认当用户点击保存按钮时我们不会改变状态，并且会执行一个调用我们的<strong>save</strong>依赖项的副作用，并且不会发出任何其他动作发送到<strong>store</strong>中。这是非常广泛的覆盖，很少的工作。</p>
<p>然而，重要的是要澄清，我们获得这种能力的一个主要原因是我们的依赖性是如何建立的。当依赖关系尽可能简单时，这种类型的测试效果最好。简单到你可以相信他们会做正确的事情只要你给他们正确的数据。它们非常简单，本身几乎没有逻辑。例如，保存和加载效果只完成将数据存入磁盘和从磁盘取出所需的最低限度的工作。它不做任何数据转换，比如JSON解码，它把这些工作留给依赖项的用户。我们的测试将测试这些数据转换，而将与磁盘交互的混乱留给依赖项。</p>
<p>为了证明这个测试确实捕捉了我们<strong>reducer</strong>的一些行为，让我们假设我们犯了一个非常糟糕的<strong>copy-pasta</strong>错误，我们不小心在保存操作中使用了加载效果:</p>
<pre><code class="language-swift">case .saveButtonTapped:
  return [
    Current.fileClient
      .load(&quot;favorite-primes.json&quot;)
      .compactMap { $0 }
      .decode(type: [Int].self, decoder: JSONDecoder())
      .catch { _ in Empty(completeImmediately: true) }
      .map(FavoritePrimesAction.loadedFavoritePrimes)
      .eraseToEffect()
  ]
</code></pre>
<p>现在，当我们运行测试时，我们得到两个失败:</p>
<ul>
<li>The effect at effects[0] emitted a value, which we know it should not.</li>
<li>The didSave flag was not flipped to true, which means the save effect was not invoked.</li>
</ul>
<p>还有其他方法可以加强这个测试。例如，我们可以提取发送到保存端点的数据，并验证它编码的整数数组是否正确。这使得我们可以用很少的工作来覆盖更多的内容，但是我们将把它留给观众作为练习。</p>
<p>这变得非常酷，我们看到了控制我们的<strong>effects</strong>的意义的开端:只要我们将依赖关系描述为带有可变字段的简单结构，只要我们强制<strong>reducer</strong>在该结构中使用这些依赖关系，我们能够将活动实现替换为模拟实现，并实际执行这些效果，以断言它们产生了正确的值来反馈给系统，或者根本没有产生任何东西。</p>
<p>因为<strong>effects</strong>应该包含很少的逻辑，并且专注于它们需要做的最小数量的工作，我们不需要担心测试<strong>effects</strong>本身的细节。如果一个<strong>effect</strong>仅仅调用苹果的api从磁盘加载数据，我们应该能够希望它能正常工作。我们关心的是捕获是否调用了特定的<strong>effect</strong>，并捕获它反馈给<strong>reducer</strong>的数据。</p>
<h2 id="5-a-nametestingthefavoriteprimesloadeffectatesting-the-favorite-primes-load-effect">5. <a name='Testingthefavoriteprimesloadeffect'></a>Testing the favorite primes load effect</h2>
<p>现在我们已经测试了保存<strong>effect</strong>，让我们测试加载<strong>effect</strong>，这有点不同，因为它需要将数据反馈到<strong>reducer</strong>。<br>
接下来，让我们看看之前编写的下一个测试:</p>
<pre><code class="language-swift">func testLoadFavoritePrimesFlow() {
  var state = [2, 3, 5, 7]

  var effects = favoritePrimesReducer(state: &amp;state, action: .loadButtonTapped)

  XCTAssertEqual(state, [2, 3, 5, 7])
  XCTAssertEqual(effects.count, 1)

  effects = favoritePrimesReducer(state: &amp;state, action: .loadedFavoritePrimes([2, 31]))

  XCTAssertEqual(state, [2, 31])
  XCTAssert(effects.isEmpty)
}
</code></pre>
<p>这将测试如果我们点击加载按钮，状态不会改变，但会发出一个<strong>effect</strong>。我们不知道是哪个<strong>effect</strong>，但我们假设它是<strong>loaddfavoriteprimes effect</strong>，因此我们在<strong>reducer</strong>中运行该动作，并断言状态已更改，没有发出进一步的<strong>effect</strong>。</p>
<p>我们想要一些测试覆盖我们忽略的<strong>effect</strong>，但如果我们只是天真地运行它，我们不会得到任何超级有用的东西:</p>
<pre><code class="language-swift">_ = effects[0].sink { action in
  print(action)
}
</code></pre>
<p>我们不想为了运行这个测试而依赖于磁盘的状态。幸运的是，我们已经控制了这种影响，所以我们可以完全绕过磁盘，直接提供数据:</p>
<pre><code class="language-swift">Current = .mock
Current.fileClient.load = { _ in .sync { try! JSONEncoder().encode([2, 31]) } }
</code></pre>
<p>现在，当我们运行测试时，打印状态执行，我们看到我们得到的动作是:</p>
<pre><code class="language-swift">loadedFavoritePrimes([2, 31])
</code></pre>
<p>这是我们真正关心的数据，因为它表明<strong>effect</strong>做了一些工作，并返回这个动作反馈到系统中。然而，如果我们试图直接断言，我们就有一个问题:</p>
<pre><code class="language-swift">_ = effects[0].sink { action in
  XCTAssertEqual(action, .loadedFavoritePrimes([2, 31]))
}
</code></pre>
<blockquote>
<p>🛑 Global function ‘XCTAssertEqual(::_:file:line:)’ requires that ‘FavoritePrimesAction’ conform to ‘Equatable’</p>
</blockquote>
<p>我们不能断言这个动作等于什么，因为它不是<strong>Equatable</strong>。这很容易解决:</p>
<pre><code class="language-swift">public enum FavoritePrimesAction: Equatable {
</code></pre>
<p>现在，测试被编译了，它通过了，因为<strong>effect</strong>产生的动作符合我们的期望。但我们不想在这里停止，我们接下来要采取这个行动，并把它馈回<strong>reducer</strong>。我们可以通过在<strong>reducer</strong>外部获取这个动作的引用，然后在之后使用它来实现:</p>
<pre><code class="language-swift">var nextAction: FavoritePrimesAction!
_ = effects[0].sink { action in
  XCTAssertEqual(action, .loadedFavoritePrimes([2, 31]))
  nextAction = action
}

effects = favoritePrimesReducer(state: &amp;state, action: nextAction)

XCTAssertEqual(state, [2, 31])
XCTAssert(effects.isEmpty)
</code></pre>
<p>现在这很酷。我们并不是手动构造我们认为会产生<strong>effect</strong>的动作，只是为了将其反馈给<strong>store</strong>。相反，我们运行这个<strong>effect</strong>，断言它产生了我们期望的动作，将它反馈给<strong>reducer</strong>，然后断言这个新动作如何改变了我们的状态。</p>
<p>我们甚至可以更进一步，断言这个<strong>effect</strong>不仅产生了我们预期的动作，而且它完成了，因此不会产生另一个<strong>effect</strong>。我们可以通过设置一个测试期望，在<strong>sink</strong>之后等待它，然后在<strong>completion block</strong>中实现这个期望:</p>
<pre><code class="language-swift">var nextAction: FavoritePrimesAction!
let receivedCompletion = self.expectation(description: &quot;receivedCompletion&quot;)
_ = effects[0].sink(
  receiveCompletion: { _ in receivedCompletion.fulfill() },
  receiveValue: { action in
    nextAction = action
    XCTAssertEqual(action, .loadedFavoritePrimes([2, 31]))
})
self.wait(for: [receivedCompletion], timeout: 0)
</code></pre>
<p>这让我们的测试更加有力。如果我们修改<strong>reducer</strong>的<strong>load effect</strong>为永不完成，我们将会得到一个失败:</p>
<pre><code class="language-swift">return [
  Current.fileClient
    .load(&quot;favorite-primes.json&quot;)
    .decode(type: [Int].self, decoder: JSONDecoder())
    .catch { _ in Empty(completeImmediately: true) }
    .map(FavoritePrimesAction.loadedFavoritePrimes)
    .merge(with: Empty(completeImmediately: false))
    .eraseToEffect()
]
</code></pre>
<blockquote>
<p>🛑 Asynchronous wait failed: Exceeded timeout of 0 seconds, with unfulfilled expectations: “receivedCompletion”.</p>
</blockquote>
<p>我们捕捉到的事实是惊人的。这意味着我们正在证明，未来不存在我们可能会意外忘记的行为。</p>
<p>从技术上讲，我们甚至可以使它更强，因为现在我们并没有断言这种<strong>effect</strong>只会产生一次。它可能已经发射了很多次，但这个测试仍然可以通过。例如，如果我们在<strong>reducer</strong>的<strong>load effect</strong>中偷偷加入这个:</p>
<pre><code class="language-swift">.merge(with: Just(FavoritePrimesAction.loadedFavoritePrimes([2, 31])))
</code></pre>
<p>一切都过去了，但显然这是非常不同的行为。所以我们仍然没有捕捉到全部的<strong>effect</strong>，但我们得到了很多。我们很快就能捕获更多，但在此之前，让我们完成控制器并在应用程序中测试其余的副作用。但在此之前，让我们通过在测试的<strong>setUp</strong>方法中设置默认的模拟环境来稍微清理一下这个测试套件，这样每个测试用例都将从一个新的模拟环境开始，他们可以按照自己的意愿来定制:</p>
<pre><code class="language-swift">override func setUp() {
  super.setUp()
  Current = .mock
}
</code></pre>
<h2 id="6-a-namecontrollingthecountereffectacontrolling-the-counter-effect">6. <a name='Controllingthecountereffect'></a>Controlling the counter effect</h2>
<p>到目前为止，这已经很有启发性了。尽管保存和加载效果看起来并不复杂，但我们能够对它们进行大量测试。我们不仅可以测试保存<strong>effect</strong>是否有效，还可以测试它是否不会产生另一个动作。我们不仅可以测试<strong>load effect</strong>是否起作用，我们还可以断言它是否起到了我们预期的作用并将正确的动作反馈给系统。我们用非常少的工作获得了大量的测试覆盖。</p>
<p>既然所有的副作用都在<strong>FavoritePrimes</strong>模块中得到了控制和测试，现在让我们把注意力转向<strong>Counter</strong>模块。它只有一个效果，即访问<strong>Wolfram Alpha API</strong>的网络请求。在此之前，这对我们来说是最难处理的，因为它是异步的，要理解它如何适合我们的体系结构需要相当多的工作。 然而，控制它就相当简单了。</p>
<p>我们目前使用的<strong>effect</strong>是这个函数，它计算给定特定n的“第n个素数”:</p>
<pre><code class="language-swift">func nthPrime(_ n: Int) -&gt; Effect&lt;Int?&gt; {

}
</code></pre>
<p>这就是我们想要控制的<strong>effect</strong>，所以让我们创建一个环境结构体并将其添加到环境中:</p>
<pre><code class="language-swift">struct CounterEnvironment {
  var nthPrime: (Int) -&gt; Effect&lt;Int?&gt;
}
</code></pre>
<p>我们也可以通过调用当前的<strong>nthPrime</strong>效果来创建这个环境的<strong>live</strong>实现:</p>
<pre><code class="language-swift">extension CounterEnvironment {
  static let live = Self(nthPrime: Counter.nthPrime)
}
</code></pre>
<p>我们可以默认当前的环境是<strong>live</strong>。</p>
<pre><code class="language-swift">var Current = CounterEnvironment.live
</code></pre>
<p>在这里，我们也可以创建<strong>mock</strong>版本:</p>
<pre><code class="language-swift">#if DEBUG
extension CounterEnvironment {
  static let mock = CounterEnvironment(nthPrime: { _ in .sync { 17 } })
}
#endif
</code></pre>
<p>环境就位后，现在我们要做的就是使用环境的<strong>nthPrime effect</strong>，而不是在这个模块中使用<strong>live</strong>:</p>
<pre><code class="language-swift">//      nthPrime(state.count)
      Current.nthPrime(state.count)
        .map(CounterAction.nthPrimeResponse)
        .receive(on: DispatchQueue.main)
        .eraseToEffect()
</code></pre>
<p>这就是完全控制模块副作用所需要的一切。 比<strong>FavoritePrimes</strong>模块简单多了。我们可以通过在<strong>playground</strong>中运行计数器屏幕而获得益处:</p>
<pre><code class="language-swift">@testable import Counter
// …

Current = .mock

PlaygroundPage.current.liveView = UIHostingController(
  rootView: CounterView(
    store: Store&lt;CounterViewState, CounterViewAction&gt;(
      initialValue: CounterViewState(
        alertNthPrime: nil,
        count: 0,
        favoritePrimes: [],
        isNthPrimeButtonDisabled: false
      ),
      reducer: logging(counterViewReducer)
    )
  )
)
</code></pre>
<p>现在当我们运行操场，点击“第n个质数是多少?”，我们会立即得到一个响应，说质数是2。这当然是错误的，但令人惊讶的是，我们可以在不依赖于<strong>Wolfram Alpha</strong>服务的情况下测试这个功能。这很好，因为我们可能在没有互联网接入的飞机上，或者可能有一天<strong>Wolfram API</strong>会宕机。当您能够正确地控制应用程序中的副作用时，这些都不重要。</p>
<h2 id="7-a-nametestingthecountereffectsatesting-the-counter-effects">7. <a name='Testingthecountereffects'></a>Testing the counter effects</h2>
<p>现在我们控制了<strong>counter effects</strong>，让我们来测试它们。我们可以从测试套件的设置中模拟环境开始，这样我们就可以确保我们永远不会使用依赖项的实时实现:</p>
<pre><code class="language-swift">override func setUp() {
  super.setUp()
  Current = .mock
}
</code></pre>
<p>前几个测试没有任何效果，所以没有什么可做的:</p>
<pre><code class="language-swift">func testIncrTapped() {
  // …
  XCTAssert(effects.isEmpty)
}

func testDecrTapped() {
  // …
  XCTAssert(effects.isEmpty)
}
</code></pre>
<p>下一个测试，<strong>testNthPrimeButtonHappyFlow</strong>，在此屏幕中测试一个完整的用户流:</p>
<pre><code class="language-swift">func testNthPrimeTappedFlow() {
  var state = CounterViewState(
    alertNthPrime: nil,
    count: 7,
    favoritePrimes: [2, 3],
    isNthPrimeButtonDisabled: false
  )

  var effects = counterViewReducer(&amp;state, .counter(.nthPrimeButtonTapped))
  XCTAssertEqual(
    state,
    CounterViewState(
      alertNthPrime: nil,
      count: 7,
      favoritePrimes: [2, 3],
      isNthPrimeButtonDisabled: true
    )
  )
  XCTAssertEqual(effects.count, 1)

  effects = counterViewReducer(&amp;state, .counter(.nthPrimeResponse(17)))
  XCTAssertEqual(
    state,
    CounterViewState(
      alertNthPrime: PrimeAlert(prime: 17),
      count: 7,
      favoritePrimes: [2, 3],
      isNthPrimeButtonDisabled: false
    )
  )
  XCTAssert(effects.isEmpty)

  effects = counterViewReducer(&amp;state, .counter(.alertDismissButtonTapped))
  XCTAssertEqual(
    state,
    CounterViewState(
      alertNthPrime: nil,
      count: 7,
      favoritePrimes: [2, 3],
      isNthPrimeButtonDisabled: false
    )
  )
  XCTAssert(effects.isEmpty)
}
</code></pre>
<p>当用户点击“第n个素数”按钮时，某些状态会发生改变，特别是<strong>isNthPrimeButtonDisabled</strong>字段会被切换为<strong>true</strong>，并返回一个<strong>effect</strong>，尽管我们目前还不知道这个<strong>effect</strong>是什么。</p>
<p>然后，我们通过向<strong>reducer</strong>中输入另一个动作来模拟来自API的响应，该<br>
是我们期望从<strong>effect</strong>中得到的，但我们仍然缺少对<strong>effect</strong>的覆盖。让我们重复我们对最喜欢的primes<strong>effect</strong>所做的，通过运行这个效应，看看我们能发现什么。我们可以在<strong>effect</strong>上调用<strong>sink</strong>来获得它的完成和值事件:</p>
<pre><code class="language-swift">_ = effects[0].sink(
  receiveCompletion: { _ in },
  receiveValue: { action in }
)
</code></pre>
<p>我们可以断言，这种<strong>effect</strong>产生的动作是我们所期望的<strong>nthprimerresponse</strong>:</p>
<pre><code class="language-swift">_ = effects[0].sink(
  receiveCompletion: { _ in },
  receiveValue: { action in
    XCTAssertEqual(action, .counter(.nthPrimeResponse(3)))
})
</code></pre>
<p>我们只需要确保我们的<strong>actions</strong>是公平的。</p>
<pre><code class="language-swift">enum CounterViewAction: Equatable {
// …
enum CounterAction: Equatable {
// …
enum PrimeModalAction: Equatable {
</code></pre>
<p>但我们期望的数字是多少?这取决于我们在模拟中使用了什么。我碰巧记得，我们使用17为这个模拟效果，但为什么要依赖于它，当我们可以用我们自己的<strong>mock</strong>覆盖端点，这是本地的测试:</p>
<pre><code class="language-swift">Current.nthPrime = { _ in .sync { 17 } }
// …
effects[0].sink(
  receiveCompletion: { _ in },
  receiveValue: { action in
    XCTAssertEqual(action, .counter(.nthPrimeResponse(17)))
})
</code></pre>
<p>但是，尽管这个测试看起来不错，它可能会更好。在处理最喜欢的素数<strong>effect</strong>时，我们还测试了它们是否像我们预期的那样完成，我们甚至捕获了该<strong>effect</strong>所发出的动作，以便我们能够将其反馈给<strong>reducer</strong>。让我们试一试:</p>
<pre><code class="language-swift">var nextAction: CounterViewAction!
let receivedCompletion = self.expectation(description: &quot;receiveCompletion&quot;)
_ = effects[0].sink(
  receiveCompletion: { _ in receivedCompletion.fulfill() },
  receiveValue: { action in
    nextAction = action
    XCTAssertEqual(action, .counter(.nthPrimeResponse(17)))
})
self.wait(for: [receivedCompletion], timeout: 0.1)

effects = counterViewReducer(&amp;state, nextAction)
</code></pre>
<ul>
<li>Created an implicitly unwrapped CounterViewAction so that we could capture the action produced by the effect</li>
<li>Created an expectation</li>
<li>Fulfilled it when we received a completion event from the effect</li>
<li>Capture the action when we receive a value</li>
<li>Waited for the expectation to be fulfilled</li>
<li>And finally sent the action back into the reducer</li>
</ul>
<p>If we run this, we get a crash:</p>
<blockquote>
<p>🛑 Fatal error: Unexpectedly found nil while implicitly unwrapping an Optional value</p>
</blockquote>
<p>看起来<strong>nextAction</strong>永远不会被设置。为了了解原因，让我们跳到<strong>reducer</strong>。</p>
<pre><code class="language-swift">Current.nthPrime(state.count)
  .map(CounterAction.nthPrimeResponse)
  .receive(on: DispatchQueue.main)
  .eraseToEffect()
</code></pre>
<p>这个<strong>effect</strong>正在做以前的<strong>effect</strong>都没有做过的事情:在另一个队列上进行工作，这需要比我们当前等待的0秒更多的时间。</p>
<pre><code class="language-swift">self.wait(for: [receivedCompletion], timeout: 0.01)
</code></pre>
<p>测试通过了，现在我们正在测试<strong>effect</strong>的覆盖率。这已经很不可思议了。我们实际上是在测试<strong>reducer</strong>是否产生了这样一种<strong>effect</strong>，即当运行时产生了我们所期望的动作。然后，当把这个动作反馈给<strong>reducer</strong>时，我们可以断言应用程序的状态是我们所期望的。</p>
<p>但我们还可以更进一步。现在我们控制了这种影响，我们可以开始测试一些边缘情况和不愉快的路径。例如，我们可以模拟当<strong>Wolfram Alpha API</strong>出现问题时会发生什么，这意味着<strong>effect</strong>返回<strong>nil</strong>:</p>
<pre><code class="language-swift">func testNthPrimeButtonUnhappyFlow() {
  Current.nthPrime = { _ in .sync { nil } }
</code></pre>
<p>这就是模拟有错误的API所需要的一切。在这之后，我们基本上可以复制粘贴之前的测试，只做一些小的改变:</p>
<pre><code class="language-swift">func testNthPrimeButtonUnhappyFlow() {
  Current.nthPrime = { _ in Effect(value: nil) }
  var state = CounterViewState(
    alertNthPrime: nil,
    count: 7,
    favoritePrimes: [2, 3],
    isNthPrimeButtonDisabled: false
  )

  var effects = counterViewReducer(&amp;state, .counter(.nthPrimeButtonTapped))
  XCTAssertEqual(
    state,
    CounterViewState(
      alertNthPrime: nil,
      count: 7,
      favoritePrimes: [2, 3],
      isNthPrimeButtonDisabled: true
    )
  )
  XCTAssertEqual(effects.count, 1)

  let receivedCompletion = self.expectation(description: &quot;receivedCompletion&quot;)
  var nextAction: CounterViewAction!
  _ = effects[0].sink(
    receiveCompletion: { _ in
      receivedCompletion.fulfill()
  },
    receiveValue: { action in
      nextAction = action
      XCTAssertEqual(action, .counter(.nthPrimeResponse(nil)))
  })
  self.wait(for: [receivedCompletion], timeout: 0.1)

  effects = counterViewReducer(&amp;state, nextAction)
  XCTAssertEqual(
    state,
    CounterViewState(
      alertNthPrime: nil,
      count: 7,
      favoritePrimes: [2, 3],
      isNthPrimeButtonDisabled: false
    )
  )
  XCTAssert(effects.isEmpty)
}
</code></pre>
<p>现在我们已经测试了整个用户流，当API失败时，用户试图请求“n个素数”。特别地，我们要确保<strong>alert</strong>不显示，并且<strong>isNthPrimeButtonDisabled</strong>正确地翻回<strong>false</strong>，以便我们可以与它交互。</p>
<h2 id="8-a-namenexttimetestergonomicsanext-time-test-ergonomics">8. <a name='Nexttime:testergonomics'></a>Next time: test ergonomics</h2>
<p>现在我们已经编写了一些真正强大的测试。我们不仅测试当用户在UI中做各种事情时应用程序的状态如何演变，而且还通过断言执行了正确的<strong>effect</strong>并返回了正确的操作来对<strong>effect</strong>进行端到端测试。</p>
<p>我们想要提及的是，我们现在构建环境的方式并不是100%理想的。它完成了这个应用程序的工作，但是一旦我们想要在许多独立模块之间共享一个依赖关系，就会遇到问题，比如我们的<strong>PrimeModal</strong>模块想要访问<strong>FileClient</strong>。我们别无选择，只能为那个模块创建一个新的<strong>FileClient</strong>实例，这意味着应用程序有两个<strong>FileClient</strong>。幸运的是，解决这个问题很简单，我们很快会在未来的一集里做这个。</p>
<p>我们的测试的另一个不好的地方是它们非常笨重。我们最近编写的一些测试超过了60行!因此，如果我们只编写10个测试，这个文件就已经超过600行了。</p>
<p>现在我们的测试有很多仪式。我们必须:</p>
<ul>
<li>create expectations</li>
<li>run the effects</li>
<li>wait for expectations</li>
<li>fulfill expectations</li>
<li>capture the next action</li>
<li>assert what action we got and feed it back into the reducer.</li>
</ul>
<p>对于我们所测试的每个效果来说，这是一种非常强烈的重复，就像我们所提到的那样，它甚至不能捕捉到所有的<strong>effect</strong>，因为可能会有一些额外的<strong>effect</strong>出现。</p>
<p>也许我们可以关注最基本的要素:我们需要做些什么来确定对我们架构的期望。它似乎可以归结为提供一些初始状态，提供我们想要测试的<strong>reducer</strong>，然后在过程中提供一系列的动作和期望，理想情况下以带有少量样板的声明式方式……下次吧!</p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://kayouyou.github.io/tag/i-r9uoo_2N/" class="tag">
                    PointFree
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://kayouyou.github.io/post/pointfree-episode-82testable-state-management-reducers/">
                  <h3 class="post-title">
                    PointFree Episode 82:Testable State Management: Reducers
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.6.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
