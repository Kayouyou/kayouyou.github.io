<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>PointFree Episode 84:Testable State Management: Ergonomics | Kayouyou&#39;s Den</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://kayouyou.github.io/favicon.ico?v=1663222449571">
<link rel="stylesheet" href="https://kayouyou.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="

PointFree Episode 84:Testable State Management: Ergonomics

Simplifying testing stateå
The shape of a test
Improving t..." />
    <meta name="keywords" content="PointFree" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://kayouyou.github.io">
        <img src="https://kayouyou.github.io/images/avatar.png?v=1663222449571" class="site-logo">
        <h1 class="site-title">Kayouyou&#39;s Den</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      The wise build bridges, while the foolish build barriers.
    </div>
    <div class="site-footer">
      豫ICP备2021012281号-1  | <a class="rss" href="https://kayouyou.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">PointFree Episode 84:Testable State Management: Ergonomics</h2>
            <div class="post-date">2021-11-28</div>
            
            <div class="post-content" v-pre>
              <!-- TOC -->
<ul>
<li><a href="#pointfree-episode-84testable-state-management-ergonomics">PointFree Episode 84:Testable State Management: Ergonomics</a>
<ul>
<li><a href="#simplifying-testing-state%C3%A5">Simplifying testing stateå</a></li>
<li><a href="#the-shape-of-a-test">The shape of a test</a></li>
<li><a href="#improving-test-feedback">Improving test feedback</a></li>
<li><a href="#trailing-closure-ergonomics">Trailing closure ergonomics</a></li>
<li><a href="#actions-sent-and-actions-received">Actions sent and actions received</a></li>
<li><a href="#assertion-edge-cases">Assertion edge cases</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<!-- # PointFree Episode 84:Testable State Management: Ergonomics -->
<p>我们不仅希望我们的架构是可测试的，而且我们还希望它非常容易地编写测试，甚至可能是编写测试的乐趣! 现在在编写测试时涉及到一些礼节，因此我们将展示如何将这些细节隐藏在一个良好的符合人体工程学的API后面。</p>
<h2 id="simplifying-testing-stateå">Simplifying testing stateå</h2>
<p>让我们从第一个问题开始:断言所有<strong>reducer</strong>的状态非常冗长。</p>
<p>例如，如果我们看一下我们最简单的<strong>counter</strong>视图测试:</p>
<pre><code class="language-swift">func testIncrButtonTapped() {
  var state = CounterViewState(
    alertNthPrime: nil,
    count: 2,
    favoritePrimes: [3, 5],
    isNthPrimeButtonDisabled: false
  )

  let effects = counterViewReducer(&amp;state, .counter(.incrTapped))

  XCTAssertEqual(
    state,
    CounterViewState(
      alertNthPrime: nil,
      count: 3,
      favoritePrimes: [3, 5],
      isNthPrimeButtonDisabled: false
    )
  )
  XCTAssertTrue(effects.isEmpty)
}
</code></pre>
<p>我们通过重新创建它的整体来断言更新状态，但我们实际上只关心一行:</p>
<pre><code class="language-swift">count: 3,
</code></pre>
<p><strong>count</strong>是唯一不同于初始状态的字段，但很难看出是哪个字段，尤其是在没有手动检查和比较每个初始化器调用的情况下的更改。</p>
<p>我们可以使用断言的<strong>message</strong>来更好地捕获我们的意图。</p>
<pre><code class="language-swift">XCTAssertEqual(
  state,
  CounterViewState(
    alertNthPrime: nil,
    count: 3,
    favoritePrimes: [3, 5],
    isNthPrimeButtonDisabled: false
  ),
  &quot;Expected count to increment to 3&quot;
)
</code></pre>
<p>但这使得测试更加冗长，包含的信息可能很快就会从断言实际试图捕获的信息中过时。</p>
<pre><code class="language-swift">//&quot;Expected count to increment to 3&quot;
</code></pre>
<p>此外，<strong>CounterViewState</strong>只包含四个字段。您可以想象在典型的应用程序代码中有更大的类型，因此这种方式的测试将很快变得不可持续。简化我们断言的方式可能会更好，以便我们的测试更直接地描述我们的<strong>expectations</strong>。</p>
<p>在将原来的状态提供给<strong>reducer</strong>之前，我们可以创建一个状态的可变副本。</p>
<pre><code class="language-swift">func testIncrButtonTapped() {
  var state = CounterViewState(
    alertNthPrime: nil,
    count: 2,
    favoritePrimes: [3, 5],
    isNthPrimeButtonDisabled: false
  )
  var expected = state
  let effects = counterViewReducer(&amp;state, .counter(.incrTapped))
</code></pre>
<p>这样，我们就可以应用突变来改变我们所期望的。在这种情况下，count:</p>
<pre><code class="language-swift">//    XCTAssertEqual(
//      state,
//      CounterViewState(
//        alertNthPrime: nil,
//        count: 3,
//        favoritePrimes: [3, 5],
//        isNthPrimeButtonDisabled: false
//      )
//    )
  expected.count = 3
  XCTAssertEqual(state, expected)
  XCTAssertTrue(effects.isEmpty)
}
</code></pre>
<p>九行变成一行，我们的期望在突变中清晰地表现出来。这比之前的一团状态要好得多。</p>
<p>但是我们测试的很大一部分仍然致力于初始化状态:我们在每个测试的开始调用整个初始化器，这使得事情变得更脆弱:如果<strong>CounterViewState</strong>结构体改变了，任何构造它的测试将无法编译并需要更新，不管这些改变是否影响任何特定的测试。</p>
<p>我们可以做的一件事是用一些合理的默认值更新<strong>CounterViewState</strong>的初始化器。</p>
<pre><code class="language-swift">public struct CounterViewState: Equatable {
  public var alertNthPrime: PrimeAlert?
  public var count: Int
  public var favoritePrimes: [Int]
  public var isNthPrimeButtonDisabled: Bool

  public init(
    alertNthPrime: PrimeAlert? = nil,
    count: Int = 0,
    favoritePrimes: [Int] = [],
    isNthPrimeButtonDisabled: Bool = false
  ) {
</code></pre>
<p>Swift编译器现在只允许我们插入特定测试所关心的值。</p>
<p>在<strong>testIncrButtonTapped</strong>的情况下，我们实际上只关心<strong>count</strong>，因为它是唯一被<strong>mutated</strong>的字段。</p>
<pre><code class="language-swift">func testIncrButtonTapped() {
  var state = CounterViewState(count: 2)
  var expected = state
  let effects = counterViewReducer(&amp;state, .counter(.incrTapped))

  expected.count = 3
  XCTAssertEqual(state, expected)
  XCTAssertTrue(effects.isEmpty)
}
</code></pre>
<p>这个测试非常简洁。</p>
<p>让我们继续并更新<strong>counter</strong>递减的测试。</p>
<pre><code class="language-swift">func testDecrButtonTapped() {
  var state = CounterViewState(count: 2)
  var expected = state
  let effects = counterViewReducer(&amp;state, .counter(.decrTapped))

  expected.count = 1
  XCTAssertEqual(state, expected)
  XCTAssertTrue(effects.isEmpty)
}
</code></pre>
<p>很简单! 21行变成了9行，专注于他们所关心的细节。</p>
<p>好了，我们的下一个测试更有实质意义。事实上，这是迄今为止我们所编写的最复杂的测试之一。它运行点击第n个质数按钮的整个流程，评估获得第n个质数响应的<strong>effect</strong>，最后<strong>dismiss</strong>结果警报。</p>
<pre><code class="language-swift">func testNthPrimeButtonHappyFlow() {
    Current.nthPrime = { _ in .sync { 17 } }

    var state = CounterViewState(
      alertNthPrime: nil,
      count: 2,
      favoritePrimes: [3, 5],
      isNthPrimeButtonDisabled: false
    )

    var effects = counterViewReducer(&amp;state, .counter(.nthPrimeButtonTapped))

    XCTAssertEqual(
      state,
      CounterViewState(
        alertNthPrime: nil,
        count: 2,
        favoritePrimes: [3, 5],
        isNthPrimeButtonDisabled: true
      )
    )
    XCTAssertEqual(effects.count, 1)

    var nextAction: CounterViewAction!
    let receivedCompletion = self.expectation(description: &quot;receivedCompletion&quot;)
    let cancellable = effects[0].sink(
      receiveCompletion: { _ in
        receivedCompletion.fulfill()
    },
      receiveValue: { action in
        XCTAssertEqual(action, .counter(.nthPrimeResponse(17)))
        nextAction = action
    }
    )
    self.wait(for: [receivedCompletion], timeout: 0.01)

    effects = counterViewReducer(&amp;state, nextAction)

    XCTAssertEqual(
      state,
      CounterViewState(
        alertNthPrime: PrimeAlert(prime: 17),
        count: 2,
        favoritePrimes: [3, 5],
        isNthPrimeButtonDisabled: false
      )
    )
    XCTAssertTrue(effects.isEmpty)

    effects = counterViewReducer(&amp;state, .counter(.alertDismissButtonTapped))

    XCTAssertEqual(
      state,
      CounterViewState(
        alertNthPrime: nil,
        count: 2,
        favoritePrimes: [3, 5],
        isNthPrimeButtonDisabled: false
      )
    )
    XCTAssertTrue(effects.isEmpty)
  }
</code></pre>
<p>它有多达62行代码。不过，如果我们只关注我们所关心的<strong>state</strong>，我们就应该能够大幅削减开支。</p>
<p>首先，我们可以简化<strong>state</strong>的实例化，将注意力集中在测试所关心的内容上:主要<strong>prime alert state</strong>以及主要按钮是否被禁用。</p>
<pre><code class="language-swift">var state = CounterViewState(alertNthPrime: nil, isNthPrimeButtonDisabled: false)
</code></pre>
<p>然后我们可以做一个可变副本来跟踪我们期望的随时间的变化的<strong>state</strong>。</p>
<pre><code class="language-swift">var expected = state
</code></pre>
<p>当点击第n个主按钮时，我们希望该按钮禁用，因此我们可以改变预期的<strong>state</strong>并针对它进行断言。</p>
<pre><code class="language-swift">var effects = counterViewReducer(&amp;state, .counter(.nthPrimeButtonTapped))

expected.isNthPrimeButtonDisabled = true
XCTAssertEqual(state, expected)
XCTAssertEqual(effects.count, 1)
</code></pre>
<p>当我们得到响应时，我们期望设置<strong>prime alert state</strong>并重新启用按钮。</p>
<pre><code class="language-swift">effects = counterViewReducer(&amp;state, nextAction)

expected.alertNthPrime = PrimeAlert(prime: 17)
expected.isNthPrimeButtonDisabled = false
XCTAssertEqual(state, expected)
XCTAssertTrue(effects.isEmpty)
</code></pre>
<p>最后，当关闭警报按钮被点击时，我们期望<strong>prime alert state</strong>为nil。</p>
<pre><code class="language-swift">effects = counterViewReducer(&amp;state, .counter(.alertDismissButtonTapped))

expected.alertNthPrime = nil
XCTAssertEqual(state, expected)
XCTAssertTrue(effects.isEmpty)
</code></pre>
<p>好了，我们开始有进展了。这个测试几乎可以在一个屏幕上完成!</p>
<h2 id="the-shape-of-a-test">The shape of a test</h2>
<p>虽然<strong>state</strong>里的许多样板已经大幅缩水，但在这个测试中仍有许多可怕的仪式:</p>
<ul>
<li>
<p>也许最突出的是我们如何处理<strong>effect</strong>。<strong>effect</strong>附加了许多样板:我们需要手动保存它们，使用sink方法手动执行它们，并执行一个<strong>XCTestExpectation</strong>动作，其中包括创建一个<strong>expectation</strong>、等待它并在完成块中完成它。我们可能会忘记很多或者所有这些步骤。</p>
</li>
<li>
<p>在测试过程中，我们的测试管理的并提供给<strong>reducer</strong>的本地的、可变的状态不太明显。将突变引入一个范围，即使是一个局部范围，也会使其更难解释。在这种情况下，我们以<strong>expected</strong>复制的形式引入了两倍的可变状态，所以我们有两倍的机会以错误的方式意外突变这些值中的任何一个。</p>
</li>
</ul>
<p>这个测试有一个非常明显的形状，但是有很多事情我们必须弄对才能做出这些断言。如果我们退后一步，看看这个形状，我们会注意到我们所编写的每个测试都遵循相同的脚本:我们构建初始状态，启动<strong>reducer</strong>，然后我们通过一个用户操作脚本，在此过程中维护我们所有的<strong>expectations</strong>。</p>
<p>如果我们可以创建一个<strong>assert helper</strong>，就像苹果的<strong>XCTAssert</strong>功能，除了它可以感知我们的架构。我们可以提供用户执行的一系列操作的描述，并且在这个过程中的每一步我们都能够断言状态是如何改变的。</p>
<p>这样的<strong>assert helper</strong>看起来像什么? 嗯，<strong>XCTAssert</strong>只是一个简单的自由函数，所以我们的助手可以是相同的:</p>
<pre><code class="language-swift">func assert(
) {
}
</code></pre>
<p>为了让这个助手完成它的工作，它必须知道我们开始的初始值和我们想要测试的<strong>reducer</strong>。让我们来提供:</p>
<pre><code class="language-swift">func assert&lt;Value, Action&gt;(
  initialValue: Value,
  reducer: Reducer&lt;Value, Action&gt;
) {
}
</code></pre>
<p>然后，有了这些配置信息，我们想给<strong>assert helper</strong>提供一个用户在与UI交互时执行的操作列表:</p>
<pre><code class="language-swift">func assert&lt;Value, Action&gt;(
  initialValue: Value,
  reducer: Reducer&lt;Value, Action&gt;,
  steps: [Action]
) {
}
</code></pre>
<p>然而，在每个步骤执行之后，我们希望进一步断言模型是如何从前一步更改的。所以仅仅提供一个操作数组是不够的，我们还想提供突变函数来描述我们期望值如何改变:</p>
<pre><code class="language-swift">func assert&lt;Value, Action&gt;(
  initialValue: Value,
  reducer: Reducer&lt;Value, Action&gt;,
  steps: [(action: Action, update: (inout Value) -&gt; Void)]
) {
}
</code></pre>
<p>如果我们可以实现这样一个函数，那么我们可以将最简单的测试更新为如下所示:</p>
<pre><code class="language-swift">func testIncrButtonTapped() {
  assert(
    initialValue: CounterViewState(count: 2),
    reducer: counterViewReducer
    steps: [
      (.counter(.incrTapped), { state in state.count = 3 })
    ]
  )
}
</code></pre>
<p>这是一个巨大的进步。我们不再重复将可变变量和动作输入<strong>reducer</strong>。</p>
<p>我们可以简化一下，用$0代替<strong>state</strong>，现在改变的<strong>state</strong>就很清楚了:</p>
<pre><code class="language-swift">(.counter(.incrTapped), { $0.count = 3 })
</code></pre>
<p>因为维护这个步骤列表非常容易，所以我们可以在这个过程中做一些更简单的断言。</p>
<pre><code class="language-swift">steps: [
  (.counter(.incrTapped), { $0.count = 3 }),
  (.counter(.incrTapped), { $0.count = 4 }),
  (.counter(.decrTapped), { $0.count = 3 })
]
</code></pre>
<p>因为编写这个测试脚本非常容易，所以我们更有能力开始测试更复杂、更细微、更微妙的用户流。</p>
<p>我们甚至可以通过使用**variadics(可变参数)**而不是数组来减少一层嵌套:</p>
<pre><code class="language-swift">func assert&lt;Value, Action&gt;(
  initialValue: Value,
  reducer: Reducer&lt;Value, Action&gt;,
  steps: (action: Action, update: (inout Value) -&gt; Void)...
) {
}

assert(
  initialValue: CounterViewState(count: 2),
  reducer: counterViewReducer
  steps:
  (.counter(.incrTapped), { $0.count = 3 }),
  (.counter(.incrTapped), { $0.count = 4 }),
  (.counter(.decrTapped), { $0.count = 3 })
)
</code></pre>
<p>这将编译并运行测试，但当然我们还没有测试任何东西，因为<strong>assert helper</strong>是空的。让我们开始实现它的主体。</p>
<p>我们希望它遍历给定的步骤并运行每个操作，以便在过程中做出断言。</p>
<pre><code class="language-swift">steps.forEach { step in

}
</code></pre>
<p>在每个步骤中，我们希望运行<strong>reducer</strong>与当前步骤的<strong>action</strong>。</p>
<pre><code class="language-swift">steps.forEach { step in
  reducer
}
</code></pre>
<p>我们需要一个可变的值来传递给<strong>reducer</strong>，所以让我们将它复制到循环外，并将它与当前步骤的<strong>action</strong>一起提供给<strong>reducer</strong>。</p>
<pre><code class="language-swift">var state = initialValue
steps.forEach { step in
  reducer(&amp;state, step.action)
}
</code></pre>
<blockquote>
<p>⚠️ Result of call to function returning ‘[Effect]’ is unused</p>
</blockquote>
<p>让我们保持简单，暂时忽略这些影响，特别是因为我们勾勒出的第一个断言没有任何影响。</p>
<p>现在，我们可以断言，突变按照我们的预期发生，这是我们的测试目前正在以非常手动的方式进行的工作，我们复制当前值，突变它，并断言它们是相等的。但这一次突变在步骤的更新函数中被捕获。</p>
<pre><code class="language-swift">var state = initialValue
steps.forEach { step in
  var expected = state
  _ reducer(&amp;state, step.action)
  step.update(&amp;expected)
  XCTAssertEqual(state, expected)
}
</code></pre>
<blockquote>
<p>🛑 Global function ‘XCTAssertEqual(::_:file:line:)’ requires that ‘Value’ conform to ‘Equatable’</p>
</blockquote>
<p>但是我们需要将<strong>Value</strong>限制为<strong>Equatable</strong>，以便将它们提供给断言。</p>
<pre><code class="language-swift">func assert&lt;Value: Equatable, Action&gt;(
</code></pre>
<p>一切都构建好了，当我们运行测试时…</p>
<blockquote>
<p>✅ Executed 1 test, with 0 failures (0 unexpected)</p>
</blockquote>
<p>Nice, it passes!</p>
<h2 id="improving-test-feedback">Improving test feedback</h2>
<p>为了确保我们实际上得到了我们期望的断言，让我们打破它的期望<strong>count</strong>。我们可以在发送<strong>decrement</strong>操作的地方增加预期的<strong>count</strong>。</p>
<pre><code class="language-swift">assert(
  initialValue: CounterViewState(count: 2),
  reducer: counterViewReducer
  steps:
  (.counter(.incrTapped), { $0.count = 3 }),
  (.counter(.incrTapped), { $0.count = 4 }),
  (.counter(.decrTapped), { $0.count = 5 })
)
</code></pre>
<p>当我们运行测试时，它会像预期的那样失败。</p>
<blockquote>
<p>❌ Executed 1 test, with 1 failure (0 unexpected)</p>
</blockquote>
<p>但不幸的是，这个失败出现在<strong>assert helper</strong>的内部深处。</p>
<pre><code class="language-swift">XCTAssertEqual(value, expected) // ❌
</code></pre>
<p>我们还必须采取一些额外的步骤来让错误消息在<strong>Xcode</strong>中更好地发挥作用。<strong>XCTest</strong>利用一些Swift特性内联显示其错误，因此我们可以使用同样的特性增强<strong>assert</strong>助手。</p>
<p><strong>XCTAssertEqual</strong>有一些隐藏的默认参数，它们负责这种行为。</p>
<pre><code class="language-swift">func XCTAssertEqual(_ expression1: @autoclosure () throws -&gt; T, _ expression2: @autoclosure () throws -&gt; T, _ message: @autoclosure () -&gt; String = “”, file: StaticString = #file, line: UInt = #line) where T : Equatable
</code></pre>
<p><strong>#file和#line</strong>都是特殊的字面值，它们指向显示它们的文件和行。当它们被用作默认参数时，它们指的是调用函数的文件和行。</p>
<p>为了突出显示调用<strong>assert helper</strong>的失败，我们可以将这些字面值引入到其签名中。</p>
<pre><code class="language-swift">func assert&lt;Value: Equatable, Action&gt;(
  initialValue: Value,
  reducer: Reducer&lt;Value, Action&gt;,
  steps: (action: Action, update: (inout Value) -&gt; Void)...,
  file: StaticString = #file,
  line: UInt = #line
) {
</code></pre>
<p>然后我们可以将它们传递给<strong>XCTest</strong>断言。</p>
<pre><code class="language-swift">XCTAssertEqual(value, expected, file: file, line: line)
</code></pre>
<p>当我们运行测试时，失败现在显示在我们调用<strong>assert</strong>的地方。</p>
<pre><code class="language-swift">assert( // ❌
</code></pre>
<p>这肯定更好，但仍然不理想。我们引入的实际失败是在最后一步。更糟的是，如果我们打破了另一个期望，说第一个:</p>
<pre><code class="language-swift">(.counter(.incrTapped), { $0.count = 2 }),
(.counter(.incrTapped), { $0.count = 4 }),
(.counter(.decrTapped), { $0.count = 5 })
</code></pre>
<p>我们得到了两个失败，这是意料之中的，但它们都在同一行上，调用了<strong>assert</strong>，但与下面的实际问题相差甚远。<br>
如果这些类型的失败以内联方式突出显示，那就更好了。</p>
<p>传递位置的一种方法是使用额外的<strong>file and line</strong>字段升级<strong>steps</strong>。</p>
<pre><code class="language-swift">steps: (action: Action, update: (inout Value) -&gt; Void, file: StaticString, line: UInt)...,
</code></pre>
<p>在这里使用默认参数也很好，但这是不可能的。</p>
<p>现在我们可以机械地在调用站点传递#<strong>file和#line</strong>。</p>
<pre><code class="language-swift">assert(
  initialValue: CounterViewState(count: 2),
  reducer: counterViewReducer,
  steps:
  (.counter(.incrTapped), { $0.count = 3 }, #file, #line),
  (.counter(.incrTapped), { $0.count = 4 }, #file, #line),
  (.counter(.decrTapped), { $0.count = 5 }, #file, #line)
)
</code></pre>
<p>为了利用这些参数，我们可以将它们传递给XCTest断言。</p>
<pre><code class="language-swift">XCTAssertEqual(value, expected, file: step.file, line: step.line)
</code></pre>
<p>当我们进行测试时，我们得到了更好的反馈。失败出现在失败步骤:</p>
<pre><code class="language-swift">(.counter(.incrTapped), { $0.count = 2 }, #file, #line), // ❌
(.counter(.incrTapped), { $0.count = 4 }, #file, #line),
(.counter(.incrTapped), { $0.count = 5 }, #file, #line)  // ❌
</code></pre>
<p>但是，这种手工工作非常笨拙。我们可以通过使用带有默认实参的函数来自动完成这项工作，实现这一目的的一种方法是将这个元组升级为带有初始化器函数的结构体。</p>
<p>我们可以将结构体称为<strong>Step</strong>。</p>
<p>它需要在<strong>Value和Action</strong>之上是通用的，它将存储一个操作、一个突变、一个文件名和一个行号。</p>
<pre><code class="language-swift">struct Step&lt;Value, Action&gt; {
  let action: Action
  let update: (inout Value) -&gt; Void
  let file: StaticString
  let line: UInt
}
</code></pre>
<p>为了获得这些#<strong>file和#line</strong>默认值，我们需要一个自定义初始化器。</p>
<pre><code class="language-swift">init(
  _ action: Action,
  _ update: @escaping (inout Value) -&gt; Void,
  file: StaticString = #file,
  line: UInt = #line
) {
  self.action = action
  self.update = update
  self.file = file
  self.line = line
}
</code></pre>
<p>现在我们只需要更新<strong>assert</strong>来使用<strong>Step</strong>而不是<strong>tuple</strong>。</p>
<pre><code class="language-swift">func assert&lt;Value: Equatable, Action&gt;(
  initialValue: Value,
  reducer: Reducer&lt;Value, Action&gt;,
  steps: Step&lt;Value, Action&gt;...,
  file: StaticString = #file,
  line: UInt = #line
) {
</code></pre>
<p>要编译内容，我们需要在断言的每一步前面加上一个大写的<strong>Step</strong>，并删除尾随的#<strong>file和#lines</strong>。</p>
<pre><code class="language-swift">steps:
Step(.counter(.incrTapped), { $0.count = 2 }),
Step(.counter(.incrTapped), { $0.count = 4 }),
Step(.counter(.decrTapped), { $0.count = 5 })
</code></pre>
<p>好了。一切都构建好了，当我们运行测试时，失败仍然在适当的行上高亮显示。</p>
<pre><code class="language-swift">Step(.counter(.incrTapped), { $0.count = 2 }), // ❌
Step(.counter(.incrTapped), { $0.count = 4 }),
Step(.counter(.decrTapped), { $0.count = 5 })  // ❌
</code></pre>
<p>好了，现在我们有了对失败的自动反馈，让我们再次让事情通过。</p>
<pre><code class="language-swift">Step(.counter(.incrTapped), { $0.count = 3 }),
Step(.counter(.incrTapped), { $0.count = 4 }),
Step(.counter(.decrTapped), { $0.count = 3 })
</code></pre>
<blockquote>
<p>✅ Executed 1 test, with 0 failures (0 unexpected)</p>
</blockquote>
<p>一切都还在运转。</p>
<h2 id="trailing-closure-ergonomics">Trailing closure ergonomics</h2>
<p>因为我们已经使用正确的结构体和初始化器升级了元组<strong>step</strong>，所以最好利用尾随闭包语法。</p>
<pre><code class="language-swift">Step(.counter(.incrTapped)) { $0.count = 3 }, // 🛑
Step(.counter(.incrTapped)) { $0.count = 4 },
Step(.counter(.decrTapped)) { $0.count = 5 }
</code></pre>
<blockquote>
<p>🛑 Generic parameter ‘Value’ could not be inferred</p>
</blockquote>
<p>不幸的是，这行不通。这个错误消息并不是特别有用，但它不能编译的原因是，尾随闭包语法只对函数的最后一个参数有效，即使后面的参数有默认值，因此可以省略。</p>
<pre><code class="language-swift">_ action: Action,
_ update: @escaping (inout Value) -&gt; Void,
file: StaticString = #file,
line: UInt = #line
</code></pre>
<p>但是，如果我们将<strong>update</strong>作为最后一个参数，那么构建就很好了。</p>
<pre><code class="language-swift">_ action: Action,
file: StaticString = #file,
line: UInt = #line,
_ update: @escaping (inout Value) -&gt; Void
</code></pre>
<h2 id="actions-sent-and-actions-received">Actions sent and actions received</h2>
<p>我们现在有了一种很好的、轻量级的领域特定语言，用于描述在显式发送给<strong>reducer</strong>的操作过程中对其状态的粒状变化，但是我们还没有重新捕获测试<strong>effect</strong>的工作。有两种主要的方式将动作反馈给store的<strong>reducer</strong>:</p>
<ul>
<li>
<p>它们通过用户<strong>action</strong>或</p>
</li>
<li>
<p>它们通过<strong>effect</strong>的结果反馈到系统中。</p>
</li>
</ul>
<p>这听起来像是我们应该在我们的领域特定语言中分离这些想法，这样我们就可以有一个脚本，声明用户做了什么动作，以及我们希望将什么动作反馈给系统。</p>
<p>让我们尝试用<strong>assert helper</strong>来描述第n个质数流。它看起来像这样:</p>
<pre><code class="language-swift">Current.nthPrime = { _ in .sync { 17 } }

assert(
  initialValue: CounterViewState(
    alertNthPrime: nil,
    isNthPrimeButtonDisabled: false
  ),
  reducer: counterViewReducer,
  steps:
  Step(.counter(.nthPrimeButtonTapped)) {
    $0.isNthPrimeButtonDisabled = true
  },
  Step(.counter(.nthPrimeResponse(17))) {
    $0.alertNthPrime = PrimeAlert(prime: 17)
    $0.isNthPrimeButtonDisabled = false
  },
  Step(.counter(.alertDismissButtonTapped)) {
    $0.alertNthPrime = nil
  }
)
</code></pre>
<p>这看起来很好，也很简洁! 如果我们运行它，它甚至会通过! 但不幸的是，它将我们带回到一个世界，在那里，我们描述的是我们期望产生<strong>effect</strong>的行为，断言并不能确保我们得到正确的结果。 理想情况下，这些步骤将记录哪些操作应该发送到<strong>store</strong>，哪些操作应该由<strong>effect</strong>接收。</p>
<p>我们可以通过在<strong>Step</strong>中引入一个新的字段来区分这种区别，该字段描述了<strong>Step</strong>的类型。我们可以使用<strong>enum</strong>来描述每种情况:一种情况是我们想通过<strong>reducer</strong>发送一个动作，另一种情况是我们希望从<strong>effect</strong>接收一个动作。</p>
<pre><code class="language-swift">enum StepType {
  case send
  case receive
}
</code></pre>
<p>然后我们可以相应地更新<strong>Step</strong>。</p>
<pre><code class="language-swift">let type: StepType

init(
  _ type: StepType,
  _ action: Action,
  file: StaticString = #file,
  line: UInt = #line,
  _ update: @escaping (inout Value) -&gt; Void
) {
  self.type = type
</code></pre>
<p>我们可以用这些新信息来更新我们的测试。首先，<strong>testIncrButtonTapped</strong>通过显式<strong>sends</strong>得到更新:</p>
<pre><code class="language-swift">assert(
  initialValue: CounterViewState(count: 2),
  reducer: counterViewReducer,
  steps:
  Step(.send, .counter(.incrTapped)) { $0.count = 3 },
  Step(.send, .counter(.incrTapped)) { $0.count = 4 },
  Step(.send, .counter(.decrTapped)) { $0.count = 3 }
)
</code></pre>
<p>接下来,<strong>testNthPrimeHappyFlow</strong>:</p>
<pre><code class="language-swift">assert(
  initialValue: CounterViewState(
    alertNthPrime: nil,
    isNthPrimeButtonDisabled: false
  ),
  reducer: counterViewReducer,
  steps:
  Step(.send, .counter(.nthPrimeButtonTapped)) {
    $0.isNthPrimeButtonDisabled = true
  },
  Step(.receive, .counter(.nthPrimeResponse(17))) {
    $0.alertNthPrime = PrimeAlert(prime: 17)
    $0.isNthPrimeButtonDisabled = false
  },
  Step(.send, .counter(.alertDismissButtonTapped)) {
    $0.alertNthPrime = nil
  }
)
</code></pre>
<p>这开始变得非常好读，但是当然，<strong>assert helper</strong>没有使用任何这些信息。</p>
<p>如何使用步骤类型的总体思想是，当一个步骤说要发送一个动作时，我们可以像平常一样调用<strong>reducer</strong>，但我们也会跟踪它所产生的<strong>effects</strong>。 然后，当我们遇到一个步骤，说我们正在接收一个动作时，我们将从我们正在跟踪的数组中取出第一个效果，运行它，并验证它产生的动作就是步骤中的动作。</p>
<p>为了处理<strong>step</strong>类型，很自然地要<strong>switch over</strong>它。</p>
<pre><code class="language-swift">switch step.type {
case .send:
case .receive:
}
</code></pre>
<p>我们可以将显式调用<strong>reducer</strong>的工作转移到<strong>send</strong>分支，发送分支告诉我们显式发送动作。</p>
<pre><code class="language-swift">switch step.type {
case .send:
  _ = reducer(&amp;state, step.action)
case .receive:
  &lt;#code#&gt;
}
</code></pre>
<p>我们目前忽略了<strong>reducer</strong>返回的<strong>effects</strong>。为了跟踪它们，我们需要引入一个变量，该变量在调用<strong>reducer</strong>时就会被设置，并且我们需要在<strong>forEach</strong>之外执行此操作，以便每个步骤都能访问前一步产生的<strong>effects</strong>。</p>
<pre><code class="language-swift">var effects: [Effect&lt;Action&gt;] = []
steps.forEach { step in
</code></pre>
<p>在循环中，我们现在可以将<strong>reducer</strong>返回的任何<strong>effects</strong>添加到数组中。</p>
<pre><code class="language-swift">effects.append(contentsOf: reducer(&amp;state, step.action))
</code></pre>
<p>好吧。现在，我们已经准备好处理在这个数组中累积的任何<strong>effects</strong>，当我们期望接收它们时。在接收分支中，我们可以从从数组中取出第一个<strong>effect</strong>开始。</p>
<pre><code class="language-swift">case .receive:
  let effect = effects.removeFirst()
}
</code></pre>
<p>然后我们可以引入<strong>expectation dance</strong>，这样我们就可以运行我们的<strong>effects</strong>来完成并提取预期的动作。首先为<strong>effect</strong>返回的操作引入一个隐式未包装的可选操作和一个测试期望。</p>
<pre><code class="language-swift">var action: Action!
let receivedCompletion = self.expectation(description: &quot;receivedCompletion&quot;) // 🛑
</code></pre>
<blockquote>
<p>🛑 Use of unresolved identifier ‘self’</p>
</blockquote>
<p>但是，因为我们是在一个自由函数中，而不是在一个<strong>XCTestCase</strong>中，所以不能使用<strong>expectation</strong>方法。然而，我们可以通过它的初始化器手动构造一个。</p>
<pre><code class="language-swift">let receivedCompletion = XCTestExpectation(description: &quot;receivedCompletion&quot;)
</code></pre>
<p>接下来，我们将使用<strong>sink</strong>运行<strong>effect</strong>，在完成时满足预期，并在接收到动作时分配操作。</p>
<pre><code class="language-swift">effect.sink(
  receiveCompletion: { _ in receivedCompletion.fulfill() },
  receiveValue: { action = $0 }
)
</code></pre>
<p>在这一点上，我们需要等待这个<strong>expectation</strong>。我们无法访问<strong>XCTestCase</strong>上的<strong>wait</strong>方法，但在<strong>XCTWaiter</strong>类上有一个类似的静态函数。</p>
<pre><code class="language-swift">XCTWaiter.wait(for: [receivedCompletion], timeout: 0.01)
</code></pre>
<blockquote>
<p>⚠️ Result of call to ‘wait(for:timeout:)’ is unused</p>
</blockquote>
<p>虽然<strong>XCTestCase</strong>上的<strong>wait</strong>方法会导致测试失败，但这个静态函数只返回一个<strong>XCTWaiter.Result</strong>，其中有几个<strong>cases</strong>描述等待期望的各种结果。如果<strong>expectation</strong>没有实现和完全，我们就会失败:</p>
<pre><code class="language-swift">if XCTWaiter.wait(for: [receivedCompletion], timeout: 0.01) != .completed {
  XCTFail(
    &quot;Timed out waiting for the effect to complete&quot;,
    file: step.file,
    line: step.line
  )
} else {
</code></pre>
<p>否则，现在我们已经有了动作，我们应该检查它是否与我们预期的相同，因此让我们快速编写一个断言。</p>
<pre><code class="language-swift">XCTAssertEqual(action, step.action, file: step.file, line: step.line)
</code></pre>
<blockquote>
<p>🛑 Global function ‘XCTAssertEqual(::_:file:line:)’ requires that ‘Action’ conform to ‘Equatable’</p>
</blockquote>
<p>这意味着我们还必须更新<strong>assert</strong>来限制<strong>Action</strong>是<strong>equatable</strong>。</p>
<pre><code class="language-swift">func assert&lt;Value: Equatable, Action: Equatable&gt;(
</code></pre>
<p>最后，我们想再次运行<strong>reducer</strong>与提取的动作。</p>
<pre><code class="language-swift">reducer(&amp;state, action)
</code></pre>
<p>我们想把它们返回的<strong>effects</strong>附加到我们处理的数组中。</p>
<pre><code class="language-swift">effects.append(contentsOf: reducer(&amp;value, action))
</code></pre>
<p>好吧，这是大量的工作! 但这基本上是我们之前手工做的工作。现在我们只需做一次，而不是手动重复，一遍又一遍。</p>
<p>如果我们进行测试，它还是通过了! 但它并没有比之前断言的更多。以前，当我们断言我们<strong>received</strong>了一个动作时，<strong>helper</strong>只是相信了我们的话。现在，<strong>helper</strong>实际上运行这些<strong>effects</strong>，并在接收动作之前对其进行断言。</p>
<p>为了证明这一点，让我们练习一下<strong>helper</strong>，以确保它正在测试一些真实的东西。例如，在正确处理<strong>assert helper</strong>中的<strong>effects</strong>之前，下面的测试应该已经通过了:</p>
<pre><code class="language-swift">Current.nthPrime = { _ in .sync { 17 } }

assert(
  initialValue: CounterViewState(
    alertNthPrime: nil,
    isNthPrimeButtonDisabled: false
  ),
  reducer: counterViewReducer,
  steps:
  Step(.send, .counter(.nthPrimeButtonTapped)) {
    $0.isNthPrimeButtonDisabled = true
  },
  Step(.receive, .counter(.nthPrimeResponse(15))) {
    $0.alertNthPrime = PrimeAlert(prime: 15)
    $0.isNthPrimeButtonDisabled = false
  },
  Step(.send, .counter(.alertDismissButtonTapped)) {
    $0.alertNthPrime = nil
  }
)
</code></pre>
<p>这是因为这个<strong>effect</strong>实际上并没有运行，它与Current.nthPrime是什么无关。因为我们正在手动重放我们所期望的<strong>effects</strong>，如果它运行的话。然而，现在<strong>assert</strong>实际上正在运行<strong>effect</strong>，实际上正在使用<strong>Current.nthPrime effect</strong>，这个测试应该失败，实际上我们得到两个失败:</p>
<blockquote>
<p>❌ XCTAssertEqual failed: (“CounterViewState(alertNthPrime: Optional(Counter.PrimeAlert(prime: 17)), count: 0, favoritePrimes: [], isNthPrimeButtonDisabled: false)”) is not equal to (“CounterViewState(alertNthPrime: Optional(Counter.PrimeAlert(prime: 15)), count: 0, favoritePrimes: [], isNthPrimeButtonDisabled: false)”) ❌ XCTAssertEqual failed: (“Optional(Counter.CounterViewAction.counter(Counter.CounterAction.nthPrimeResponse(Optional(17))))”) is not equal to (“Optional(Counter.CounterViewAction.counter(Counter.CounterAction.nthPrimeResponse(Optional(15))))”)</p>
</blockquote>
<p>第一个失败是由于<strong>state</strong>并没有按照我们预期的方式改变。其次是由于<strong>action</strong>不匹配的事实。</p>
<p>因此，我们对<strong>assert</strong>函数的更新让我们能够捕获真实的<strong>effect</strong>行为。当我们断言一个<strong>action</strong>被发送时，我们不仅断言状态是如何改变的，而且我们还累积从减速机返回的所有<strong>effects</strong>。然后,当我们收到断言,一个<strong>action</strong>,我们第一个<strong>effect</strong>从数组,运行它,并断言行动我们将收到匹配的实际行动释放的<strong>effect</strong>,我们将这个<strong>action</strong>反馈给<strong>reducer</strong>以确保它以我们认为它应该的方式改变状态。</p>
<h2 id="assertion-edge-cases">Assertion edge cases</h2>
<p>但事情还不太对劲。有很多<strong>assert</strong>不会捕捉到的边界情况，所以让我们逐个研究它们。</p>
<p>首先，如果我们注释掉中间步骤，我们期望从一个<strong>effect</strong>中接收一个<strong>action</strong>:</p>
<pre><code class="language-swift">assert(
      initialValue: CounterViewState(
        alertNthPrime: nil,
        isNthPrimeButtonDisabled: false
      ),
      reducer: counterViewReducer,
      steps:
      Step(.send, .counter(.nthPrimeButtonTapped)) {
        $0.isNthPrimeButtonDisabled = true
      },
//          Step(.receive, .counter(.nthPrimeResponse(17))) {
//            $0.alertNthPrime = PrimeAlert(prime: 17)
//            $0.isNthPrimeButtonDisabled = false
//          },
      Step(.send, .counter(.alertDismissButtonTapped)) {
        $0.alertNthPrime = nil
      }
    )
</code></pre>
<p>测试仍然通过，即使有一个<strong>effect</strong>应该被执行。这是因为我们只在明确期望接收<strong>action</strong>时才考虑<strong>effects</strong>。<br>
即使我们没有考虑到一些悬而未决的<strong>effects</strong>，<strong>assert</strong>的<strong>send</strong>分支也将愉快地继续前进。</p>
<pre><code class="language-swift">case .send:
  effects.append(contentsOf: reducer(&amp;value, step.action))
</code></pre>
<p>我们要做的是确保在为一个已发送的<strong>action</strong>运行<strong>reducer</strong>之前没有悬而未决的<strong>effects</strong>。</p>
<pre><code class="language-swift">case .send:
  if !effects.isEmpty {
    XCTFail(
      &quot;Action sent before handling \(effects.count) pending effect(s)&quot;,
      file: step.file,
      line: step.line
    )
  }
  effects.append(contentsOf: reducer(&amp;value, step.action))
</code></pre>
<p>当我们重新运行测试时，它失败了:</p>
<pre><code class="language-swift">//      Step(.receive, .counter(.nthPrimeResponse(17))) {
//        $0.alertNthPrime = PrimeAlert(prime: 17)
//        $0.isNthPrimeButtonDisabled = false
//      },
      Step(.send, .counter(.alertDismissButtonTapped)) { // ❌
        $0.alertNthPrime = nil
      }
</code></pre>
<blockquote>
<p>❌ failed - Action sent before handling 1 pending effect(s)</p>
</blockquote>
<p>但是，如果我们注释掉最后一步，事情就继续了:</p>
<pre><code class="language-swift">Step(.send, .counter(.nthPrimeButtonTapped)) {
        $0.isNthPrimeButtonDisabled = true
      }//,
//      Step(.receive, .counter(.nthPrimeResponse(17))) {
//        $0.alertNthPrime = PrimeAlert(prime: 17)
//        $0.isNthPrimeButtonDisabled = false
//      },
//      Step(.send, .counter(.alertDismissButtonTapped)) {
//        $0.alertNthPrime = nil
//      }
</code></pre>
<blockquote>
<p>✅ Executed 1 test, with 0 failures (0 unexpected)</p>
</blockquote>
<p>这不太理想。没有测试<strong>nthprimerresponse</strong>操作返回的<strong>effect</strong>。我们想要的是我们的<strong>helper</strong>为我们抓住这些错误，这样我们就不会忘记断言一个<strong>effect</strong>。</p>
<p>要解决这个问题，我们需要做一个最后的断言。在循环遍历所有给定的步骤之后，如果<strong>effect</strong>数组包含任何挂起的<strong>effect</strong>，则应该失败。</p>
<pre><code class="language-swift">if !effects.isEmpty {
  XCTFail(
    &quot;Assertion failed to handle \(effects.count) pending effect(s)&quot;,
    file: file,
    line: line
  )
}
</code></pre>
<p>有了这个添加，我们的测试又失败了:</p>
<pre><code class="language-swift">assert( // ❌
</code></pre>
<blockquote>
<p>❌ failed - Assertion failed to handle 1 pending effect(s)</p>
</blockquote>
<p>但是，如果断言期望在没有<strong>effect</strong>的情况下收到<strong>effect</strong>，该怎么办呢? 我们可以注释掉第一步，然后注释第二步，这样做:</p>
<pre><code class="language-swift">steps:
//      Step(.send, .counter(.nthPrimeButtonTapped)) {
//        $0.isNthPrimeButtonDisabled = true
//      },
      Step(.receive, .counter(.nthPrimeResponse(17))) {
        $0.alertNthPrime = PrimeAlert(prime: 17)
        $0.isNthPrimeButtonDisabled = false
      },
      Step(.send, .counter(.alertDismissButtonTapped)) {
        $0.alertNthPrime = nil
      }
</code></pre>
<p>这一次，当我们运行测试时，我们遇到了崩溃!</p>
<pre><code class="language-swift">case .receive:
  let effect = effects.removeFirst() // 🛑
</code></pre>
<blockquote>
<p>🛑 Fatal error: Can’t remove first element from an empty collection</p>
</blockquote>
<p>因为数组上的<strong>removeFirst</strong>方法返回一个非可选元素，所以如果没有这样的元素存在，它就必须崩溃。虽然我们希望测试在预期有<strong>effect</strong>而实际没有<strong>effect</strong>时失败，但我们不希望使整个测试套件崩溃。</p>
<p>所以，让我们主动失败，当我们期望有效果，但实际没有时。</p>
<pre><code class="language-swift">case .receive:
  guard !effects.isEmpty else {
    XCTFail(
      &quot;No pending effects to receive from&quot;,
      file: step.file,
      line: step.line
    )
    break
  }
</code></pre>
<p>现在，测试失败得稍微好一些。</p>
<pre><code class="language-swift">steps:
//      Step(.send, .counter(.nthPrimeButtonTapped)) {
//        $0.isNthPrimeButtonDisabled = true
//      },
      Step(.receive, .counter(.nthPrimeResponse(17))) { // ❌
        $0.alertNthPrime = PrimeAlert(prime: 17)
        $0.isNthPrimeButtonDisabled = false
      },
</code></pre>
<blockquote>
<p>❌ failed - No pending effects to receive from</p>
</blockquote>
<p>这应该涵盖了大多数常见的边情况。所以让我们把所有东西都注释回来，以获得一个合格的测试:</p>
<pre><code class="language-swift">Step(.send, .counter(.nthPrimeButtonTapped)) {
  $0.isNthPrimeButtonDisabled = true
},
Step(.receive, .counter(.nthPrimeResponse(17))) {
  $0.alertNthPrime = PrimeAlert(prime: 17)
  $0.isNthPrimeButtonDisabled = false
},
Step(.send, .counter(.alertDismissButtonTapped)) {
  $0.alertNthPrime = nil
}
</code></pre>
<blockquote>
<p>✅ Executed 1 test, with 0 failures (0 unexpected)</p>
</blockquote>
<h2 id="conclusion">Conclusion</h2>
<p>好了，<strong>assert</strong>助手看起来真的很好。它让我们准备一些状态来用<strong>reducer</strong>进行测试，然后我们可以用我们预期的突变和预期的<strong>effect</strong>反馈给系统的动作来对它进行断言，并提供尽可能多的动作。我们还可以做一些事情来增强这个<strong>helpers</strong>，比如添加对“<strong>fire-and-forget</strong>”<strong>effect</strong>的支持，但它已经为我们做了很多。</p>
<p>让我们清理一下，更好地、更全面地看待我们所取得的成就。</p>
<p>首先，让我们将<strong>assert helper</strong>及其依赖项移动到它们自己的文件中。不过，理想情况下，它们应该存在于自己的测试<strong>helper</strong>模块中，可以导入到任何使用可组合架构的测试目标中。</p>
<pre><code class="language-swift">import ComposableArchitecture
import XCTest

enum StepType {
  case send
  case receive
}

struct Step&lt;Value, Action&gt; {
  let type: StepType
  let action: Action
  let update: (inout Value) -&gt; Void
  let file: StaticString
  let line: UInt

  init(
    _ type: StepType,
    _ action: Action,
    file: StaticString = #file,
    line: UInt = #line,
    _ update: @escaping (inout Value) -&gt; Void
  ) {
    self.type = type
    self.action = action
    self.update = update
    self.file = file
    self.line = line
  }
}

func assert&lt;Value: Equatable, Action: Equatable&gt;(
  initialValue: Value,
  reducer: Reducer&lt;Value, Action&gt;,
  steps: Step&lt;Value, Action&gt;...,
  file: StaticString = #file,
  line: UInt = #line
) {
  var state = initialValue
  var effects: [Effect&lt;Action&gt;] = []

  steps.forEach { step in
    var expected = state

    switch step.type {
    case .send:
      if !effects.isEmpty {
        XCTFail(&quot;Action sent before handling \(effects.count) pending effect(s)&quot;, file: step.file, line: step.line)
      }
      effects.append(contentsOf: reducer(&amp;state, step.action))

    case .receive:
      guard !effects.isEmpty else {
        XCTFail(&quot;No pending effects to receive from&quot;, file: step.file, line: step.line)
        break
      }
      let effect = effects.removeFirst()
      var action: Action!
      let receivedCompletion = XCTestExpectation(description: &quot;receivedCompletion&quot;)
      _ = effect.sink(
        receiveCompletion: { _ in
          receivedCompletion.fulfill()
      },
        receiveValue: { action = $0 }
      )
      if XCTWaiter.wait(for: [receivedCompletion], timeout: 0.01) != .completed {
        XCTFail(&quot;Timed out waiting for the effect to complete&quot;, file: step.file, line: step.line)
      }
      XCTAssertEqual(action, step.action, file: step.file, line: step.line)
      effects.append(contentsOf: reducer(&amp;state, action))
    }

    step.update(&amp;expected)
    XCTAssertEqual(state, expected, file: step.file, line: step.line)
  }
  if !effects.isEmpty {
    XCTFail(&quot;Assertion failed to handle \(effects.count) pending effect(s)&quot;, file: file, line: line)
  }
}
</code></pre>
<p>现在，我们可以通过删除一些注释掉的和过时的测试代码来清理计数器测试文件，并使用断言助手，在我们之前手动测试体系结构的地方。</p>
<pre><code class="language-swift">import XCTest
@testable import Counter

class CounterTests: XCTestCase {
  override class func setUp() {
    super.setUp()
    Current = .mock
  }

  func testIncrDecrButtonTapped() {
    assert(
      initialValue: CounterViewState(count: 2),
      reducer: counterViewReducer,
      steps:
      Step(.send, .counter(.incrTapped)) { $0.count = 3 },
      Step(.send, .counter(.incrTapped)) { $0.count = 4 },
      Step(.send, .counter(.decrTapped)) { $0.count = 3 }
    )
  }

  func testNthPrimeButtonHappyFlow() {
    Current.nthPrime = { _ in .sync { 17 } }

    assert(
      initialValue: CounterViewState(
        alertNthPrime: nil,
        isNthPrimeButtonDisabled: false
      ),
      reducer: counterViewReducer,
      steps:
      Step(.send, .counter(.nthPrimeButtonTapped)) {
        $0.isNthPrimeButtonDisabled = true
      },
      Step(.receive, .counter(.nthPrimeResponse(17))) {
        $0.alertNthPrime = PrimeAlert(prime: 17)
        $0.isNthPrimeButtonDisabled = false
      },
      Step(.send, .counter(.alertDismissButtonTapped)) {
        $0.alertNthPrime = nil
      }
    )
  }

  func testNthPrimeButtonUnhappyFlow() {
    Current.nthPrime = { _ in .sync { nil } }

    assert(
      initialValue: CounterViewState(
        alertNthPrime: nil,
        isNthPrimeButtonDisabled: false
      ),
      reducer: counterViewReducer,
      steps:
      Step(.send, .counter(.nthPrimeButtonTapped)) {
        $0.isNthPrimeButtonDisabled = true
      },
      Step(.receive, .counter(.nthPrimeResponse(nil))) {
        $0.isNthPrimeButtonDisabled = false
      }
    )
  }

  func testPrimeModal() {
    assert(
      initialValue: CounterViewState(
        count: 2,
        favoritePrimes: [3, 5]
      ),
      reducer: counterViewReducer,
      steps:
      Step(.send, .primeModal(.saveFavoritePrimeTapped)) {
        $0.favoritePrimes = [3, 5, 2]
      },
      Step(.send, .primeModal(.removeFavoritePrimeTapped)) {
        $0.favoritePrimes = [3, 5]
      }
    )
  }
}
</code></pre>
<p>所有的测试仍然通过了，但是它们现在非常简洁地准确地描述了用户所做的事情以及反馈给系统的影响。</p>
<p>现在整个文件只有80行代码，而以前，我们有几个60行测试，使整个文件的代码超过200行。在使用这个<strong>helper</strong>的过程中，我们已经隐藏了很多样板和痛苦! 这使得写作和阅读测试成为一种愉快的体验。</p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://kayouyou.github.io/tag/i-r9uoo_2N/" class="tag">
                    PointFree
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://kayouyou.github.io/post/pointfree-episode-83testable-state-management-effects/">
                  <h3 class="post-title">
                    PointFree Episode 83:Testable State Management: Effects
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.6.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
