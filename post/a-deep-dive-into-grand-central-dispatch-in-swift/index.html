<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>A deep dive into Grand Central Dispatch in Swift | Kayouyou&#39;s Den</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico?v=1663222449412">
<link rel="stylesheet" href="http://localhost:4000/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="Grand Central Dispatch(ç®€ç§°GCD)æ˜¯Swiftå¼€å‘äººå‘˜å¤šæ¬¡ä½¿ç”¨çš„åŸºæœ¬æŠ€æœ¯ä¹‹ä¸€ã€‚å®ƒä¸»è¦ä»¥èƒ½å¤Ÿåœ¨ä¸åŒçš„å¹¶å‘é˜Ÿåˆ—ä¸Šåˆ†æ´¾å·¥ä½œè€Œé—»åï¼Œå¹¶ä¸”ç»å¸¸è¢«ç”¨æ¥ç¼–å†™è¿™æ ·çš„ä»£ç :
DispatchQueue.main.async {
   ..." />
    <meta name="keywords" content="concurrency,GCD" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="http://localhost:4000">
        <img src="http://localhost:4000/images/avatar.png?v=1663222449412" class="site-logo">
        <h1 class="site-title">Kayouyou&#39;s Den</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            é¦–é¡µ
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            å½’æ¡£
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            æ ‡ç­¾
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            å…³äº
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      The wise build bridges, while the foolish build barriers.
    </div>
    <div class="site-footer">
      è±«ICPå¤‡2021012281å·-1  | <a class="rss" href="http://localhost:4000/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">A deep dive into Grand Central Dispatch in Swift</h2>
            <div class="post-date">2017-06-04</div>
            
            <div class="post-content" v-pre>
              <p>Grand Central Dispatch(ç®€ç§°GCD)æ˜¯Swiftå¼€å‘äººå‘˜å¤šæ¬¡ä½¿ç”¨çš„åŸºæœ¬æŠ€æœ¯ä¹‹ä¸€ã€‚å®ƒä¸»è¦ä»¥èƒ½å¤Ÿåœ¨ä¸åŒçš„å¹¶å‘é˜Ÿåˆ—ä¸Šåˆ†æ´¾å·¥ä½œè€Œé—»åï¼Œå¹¶ä¸”ç»å¸¸è¢«ç”¨æ¥ç¼–å†™è¿™æ ·çš„ä»£ç :</p>
<pre><code class="language-swift">DispatchQueue.main.async {
    // Run async code on the main queue
}
</code></pre>
<p>ä½†å¦‚æœæˆ‘ä»¬å†æ·±å…¥ä¸€ç‚¹ï¼Œå°±ä¼šå‘ç°GCDè¿˜æœ‰ä¸€å¥—çœŸæ­£å¼ºå¤§çš„apiå’Œç‰¹æ€§ï¼Œä½†ä¸æ˜¯æ¯ä¸ªäººéƒ½çŸ¥é“ã€‚æœ¬å‘¨ï¼Œè®©æˆ‘ä»¬è¶…è¶Šasync{}ï¼Œçœ‹çœ‹GCDåœ¨å“ªäº›æƒ…å†µä¸‹çœŸçš„å¾ˆæœ‰ç”¨ï¼Œä»¥åŠå®ƒå¦‚ä½•ä¸ºè®¸å¤šå…¶ä»–æ›´å¸¸è§çš„åŸºç¡€apiæä¾›æ›´ç®€å•(å’Œæ›´â€œå¿«é€Ÿâ€)çš„é€‰é¡¹ã€‚</p>
<h2 id="delaying-a-cancellable-task-with-dispatchworkitem">Delaying a cancellable task with DispatchWorkItem</h2>
<p>å…³äºGCDçš„ä¸€ä¸ªå¸¸è§è¯¯è§£æ˜¯â€œä¸€æ—¦ä½ å®‰æ’äº†ä¸€ä¸ªä»»åŠ¡ï¼Œå®ƒå°±ä¸èƒ½è¢«å–æ¶ˆï¼Œä½ éœ€è¦ä½¿ç”¨Operationè¿™ä¸ªæ“ä½œAPIâ€ã€‚è¿™åœ¨è¿‡å»æ˜¯æ­£ç¡®çš„ï¼Œéšç€iOS 8å’ŒmacOS 10.10å¼•å…¥äº†DispatchWorkItemï¼Œå®ƒåœ¨ä¸€ä¸ªéå¸¸å®¹æ˜“ä½¿ç”¨çš„APIä¸­æä¾›äº†ç²¾ç¡®çš„åŠŸèƒ½ã€‚</p>
<p>å‡è®¾æˆ‘ä»¬çš„UIæœ‰ä¸€ä¸ªæœç´¢æ ï¼Œå½“ç”¨æˆ·è¾“å…¥ä¸€ä¸ªå­—ç¬¦æ—¶ï¼Œæˆ‘ä»¬é€šè¿‡è°ƒç”¨åç«¯æ¥æ‰§è¡Œæœç´¢ã€‚å› ä¸ºç”¨æˆ·å¯ä»¥å¿«é€Ÿè¾“å…¥ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸æƒ³é©¬ä¸Šå¯åŠ¨ç½‘ç»œè¯·æ±‚(è¿™å¯èƒ½ä¼šæµªè´¹å¤§é‡æ•°æ®å’ŒæœåŠ¡å™¨å®¹é‡)ï¼Œç›¸åï¼Œæˆ‘ä»¬å°†â€œdebounceâ€è¿™äº›äº‹ä»¶ï¼Œåªåœ¨ç”¨æˆ·åœ¨0.25ç§’å†…æ²¡æœ‰è¾“å…¥æ—¶æ‰§è¡Œè¯·æ±‚ã€‚</p>
<p>è¿™å°±æ˜¯DispatchWorkItemçš„ä½œç”¨æ‰€åœ¨ã€‚ é€šè¿‡å°†æˆ‘ä»¬çš„è¯·æ±‚ä»£ç å°è£…åœ¨ä¸€ä¸ªå·¥ä½œé¡¹ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“åœ°åœ¨å®ƒè¢«ä¸€ä¸ªæ–°çš„æ›¿æ¢æ—¶å–æ¶ˆå®ƒï¼Œåƒè¿™æ ·:</p>
<pre><code class="language-swift">class SearchViewController: UIViewController, UISearchBarDelegate {
    // We keep track of the pending work item as a property
    private var pendingRequestWorkItem: DispatchWorkItem?

    func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) {
        // Cancel the currently pending item
        pendingRequestWorkItem?.cancel()

        // Wrap our request in a work item
        let requestWorkItem = DispatchWorkItem { [weak self] in
            self?.resultsLoader.loadResults(forQuery: searchText)
        }

        // Save the new work item and execute it after 250 ms
        pendingRequestWorkItem = requestWorkItem
        DispatchQueue.main.asyncAfter(deadline: .now() + .milliseconds(250),
                                      execute: requestWorkItem)
    }
}
</code></pre>
<p>æ­£å¦‚æˆ‘ä»¬ä¸Šé¢æ‰€çœ‹åˆ°çš„ï¼Œåœ¨Swiftä¸­ä½¿ç”¨DispatchWorkItemå®é™…ä¸Šæ¯”ä½¿ç”¨è®¡æ—¶å™¨æˆ–Operationè¦ç®€å•å’Œæ¼‚äº®å¾—å¤šï¼Œè¿™è¦å½’åŠŸäºå°¾éšé—­åŒ…è¯­æ³•å’Œå°†GCDå¯¼å…¥Swiftçš„è‰¯å¥½æ€§èƒ½ã€‚ æˆ‘ä»¬ä¸éœ€è¦@objcæ ‡è®°çš„æ–¹æ³•æˆ–#é€‰æ‹©å™¨â€”â€”è¿™äº›éƒ½å¯ä»¥ç”¨é—­åŒ…æ¥å®Œæˆã€‚</p>
<h2 id="grouping-and-chaining-tasks-with-dispatchgroup">Grouping and chaining tasks with DispatchGroup</h2>
<p>æœ‰æ—¶æˆ‘ä»¬éœ€è¦æ‰§è¡Œä¸€ç»„æ“ä½œï¼Œç„¶åæ‰èƒ½ç»§ç»­æˆ‘ä»¬çš„é€»è¾‘ã€‚ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬éœ€è¦åœ¨åˆ›å»ºæ¨¡å‹ä¹‹å‰ä»ä¸€ç»„æ•°æ®æºåŠ è½½æ•°æ®ã€‚ä¸å¿…è‡ªå·±è·Ÿè¸ªæ‰€æœ‰çš„æ•°æ®æºï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“åœ°ä¸DispatchGroupåŒæ­¥å·¥ä½œã€‚</p>
<p>ä½¿ç”¨åˆ†æ´¾ç»„è¿˜æœ‰ä¸€ä¸ªå¾ˆå¤§çš„ä¼˜åŠ¿ï¼Œé‚£å°±æ˜¯æˆ‘ä»¬çš„ä»»åŠ¡å¯ä»¥åœ¨å•ç‹¬çš„é˜Ÿåˆ—ä¸­å¹¶å‘åœ°è¿è¡Œã€‚è¿™ä½¿æˆ‘ä»¬èƒ½å¤Ÿä»ç®€å•çš„å¼€å§‹ï¼Œç„¶ååœ¨éœ€è¦æ—¶è½»æ¾åœ°æ·»åŠ å¹¶å‘æ€§ï¼Œè€Œä¸å¿…é‡å†™ä»»ä½•ä»»åŠ¡ã€‚ æˆ‘ä»¬æ‰€è¦åšçš„å°±æ˜¯å¹³è¡¡è°ƒç”¨è°ƒåº¦ç»„ä¸Šçš„enter()å’Œleave()ï¼Œè®©å®ƒåŒæ­¥æˆ‘ä»¬çš„ä»»åŠ¡ã€‚</p>
<p>è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªä¾‹å­ï¼Œåœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬ä»æœ¬åœ°å­˜å‚¨ã€iCloudé©±åŠ¨å™¨å’Œåç«¯ç³»ç»ŸåŠ è½½ç¬”è®°ï¼Œç„¶åå°†æ‰€æœ‰çš„ç»“æœåˆå¹¶æˆä¸€ä¸ªNoteCollection:</p>
<pre><code class="language-swift">// First, we create a group to synchronize our tasks
let group = DispatchGroup()

// NoteCollection is a thread-safe collection class for storing notes
let collection = NoteCollection()

// The 'enter' method increments the group's task countâ€¦
group.enter()
localDataSource.load { notes in
    collection.add(notes)
    // â€¦while the 'leave' methods decrements it
    group.leave()
}

group.enter()
iCloudDataSource.load { notes in
    collection.add(notes)
    group.leave()
}

group.enter()
backendDataSource.load { notes in
    collection.add(notes)
    group.leave()
}

// This closure will be called when the group's task count reaches 0
group.notify(queue: .main) { [weak self] in
    self?.render(collection)
}
</code></pre>
<p>ä¸Šé¢çš„ä»£ç å¯ä»¥å·¥ä½œï¼Œä½†æ˜¯æœ‰å¾ˆå¤šé‡å¤çš„åœ°æ–¹ã€‚è®©æˆ‘ä»¬æŠŠå®ƒé‡æ„æˆä¸€ä¸ªæ•°ç»„æ‰©å±•ï¼Œä½¿ç”¨æ•°æ®æºåè®®ä½œä¸ºå…¶å…ƒç´ ç±»å‹çš„åŒç±»å‹çº¦æŸ:</p>
<pre><code class="language-swift">extension Array where Element == DataSource {
    func load(completionHandler: @escaping (NoteCollection) -&gt; Void) {
        let group = DispatchGroup()
        let collection = NoteCollection()

        // De-duplicate the synchronization code by using a loop
        for dataSource in self {
            group.enter()
            dataSource.load { notes in
                collection.add(notes)
                group.leave()
            }
        }

        group.notify(queue: .main) {
            completionHandler(collection)
        }
    }
}
</code></pre>
<p>æœ‰äº†ä¸Šé¢çš„æ‰©å±•ï¼Œæˆ‘ä»¬ç°åœ¨å¯ä»¥å°†ä¹‹å‰çš„ä»£ç ç®€åŒ–ä¸º:</p>
<pre><code class="language-swift">let dataSources: [DataSource] = [
    localDataSource,
    iCloudDataSource,
    backendDataSource
]

dataSources.load { [weak self] collection in
    self?.render(collection)
}
</code></pre>
<p>é€ å·¥ååˆ†æœ­å®ç²¾è‡´;</p>
<h2 id="waiting-for-asynchronous-tasks-with-dispatchsemaphore">Waiting for asynchronous tasks with DispatchSemaphore</h2>
<p>DispatchGroupæä¾›äº†ä¸€ç§ç®€å•çš„æ–¹æ³•æ¥åŒæ­¥ä¸€ç»„å¼‚æ­¥æ“ä½œï¼ŒåŒæ—¶ä»ç„¶ä¿æŒå¼‚æ­¥çŠ¶æ€ï¼Œè€ŒDispatchSemaphoreåˆ™æä¾›äº†ä¸€ç§åŒæ­¥ç­‰å¾…ä¸€ç»„å¼‚æ­¥ä»»åŠ¡çš„æ–¹æ³•ã€‚è¿™åœ¨å‘½ä»¤è¡Œå·¥å…·æˆ–è„šæœ¬ä¸­éå¸¸æœ‰ç”¨ï¼Œå› ä¸ºæˆ‘ä»¬æ²¡æœ‰åº”ç”¨ç¨‹åºrun loopï¼Œè€Œåªæ˜¯åœ¨å…¨å±€ä¸Šä¸‹æ–‡ä¸­åŒæ­¥æ‰§è¡Œï¼Œç›´åˆ°å®Œæˆã€‚</p>
<p>åƒDispatchGroupä¸€æ ·ï¼Œsemaphore APIéå¸¸ç®€å•ï¼Œæˆ‘ä»¬åªé€šè¿‡è°ƒç”¨wait()æˆ–signal()æ¥å¢åŠ æˆ–å‡å°‘ä¸€ä¸ªå†…éƒ¨è®¡æ•°å™¨ã€‚åœ¨signal()ä¹‹å‰è°ƒç”¨wait()å°†é˜»å¡å½“å‰é˜Ÿåˆ—ï¼Œç›´åˆ°æ¥æ”¶åˆ°ä¿¡å·ã€‚</p>
<p>è®©æˆ‘ä»¬åœ¨ä¹‹å‰çš„æ‰©å±•æ•°ç»„ä¸Šåˆ›å»ºå¦ä¸€ä¸ªé‡è½½ï¼Œå®ƒä»¥åŒæ­¥æ–¹å¼è¿”å›ä¸€ä¸ªNoteCollectionï¼Œæˆ–è€…æŠ›å‡ºä¸€ä¸ªé”™è¯¯ã€‚æˆ‘ä»¬å°†é‡ç”¨ä¹‹å‰åŸºäºdispatchgroupçš„ä»£ç ï¼Œä½†åªæ˜¯ä½¿ç”¨ä¸€ä¸ªsemaphoreæ¥åè°ƒè¯¥ä»»åŠ¡ã€‚</p>
<pre><code class="language-swift">extension Array where Element == DataSource {
    func load() throws -&gt; NoteCollection {
        let semaphore = DispatchSemaphore(value: 0)
        var loadedCollection: NoteCollection?

        // We create a new queue to do our work on, since calling wait() on
        // the semaphore will cause it to block the current queue
        let loadingQueue = DispatchQueue.global()

        loadingQueue.async {
            // We extend 'load' to perform its work on a specific queue
            self.load(onQueue: loadingQueue) { collection in
                loadedCollection = collection

                // Once we're done, we signal the semaphore to unblock its queue
                semaphore.signal()
            }
        }

        // Wait with a timeout of 5 seconds
        semaphore.wait(timeout: .now() + 5)

        guard let collection = loadedCollection else {
            throw NoteLoadingError.timedOut
        }

        return collection
    }
}
</code></pre>
<p>åœ¨Arrayä¸Šä½¿ç”¨ä¸Šè¿°æ–°æ–¹æ³•ï¼Œæˆ‘ä»¬ç°åœ¨å¯ä»¥åƒè¿™æ ·åœ¨è„šæœ¬æˆ–å‘½ä»¤è¡Œå·¥å…·ä¸­åŒæ­¥åŠ è½½notes:</p>
<pre><code class="language-swift">let dataSources: [DataSource] = [
    localDataSource,
    iCloudDataSource,
    backendDataSource
]

do {
    let collection = try dataSources.load()
    output(collection)
} catch {
    output(error)
}
</code></pre>
<h2 id="observing-changes-in-a-file-with-dispatchsource">Observing changes in a file with DispatchSource</h2>
<p>æˆ‘æƒ³æåˆ°çš„GCDçš„æœ€åä¸€ä¸ªâ€œä¸å¤ªä¸ºäººæ‰€çŸ¥â€çš„ç‰¹æ€§æ˜¯å®ƒå¦‚ä½•æä¾›ä¸€ç§æ–¹æ³•æ¥è§‚å¯Ÿæ–‡ä»¶ç³»ç»Ÿä¸­æ–‡ä»¶çš„å˜åŒ–ã€‚ ä¸DispatchSemaphoreä¸€æ ·ï¼Œå¦‚æœæˆ‘ä»¬æƒ³è‡ªåŠ¨å¯¹ç”¨æˆ·ç¼–è¾‘çš„æ–‡ä»¶åšå‡ºååº”ï¼Œè¿™åœ¨è„šæœ¬æˆ–å‘½ä»¤è¡Œå·¥å…·ä¸­éå¸¸æœ‰ç”¨ã€‚ è¿™ä½¿æˆ‘ä»¬èƒ½å¤Ÿè½»æ¾åœ°æ„å»ºå…·æœ‰â€œå®æ—¶ç¼–è¾‘â€ç‰¹æ€§çš„å¼€å‘å·¥å…·ã€‚</p>
<p>DispatchSourceæœ‰å‡ ç§ä¸åŒçš„å˜ä½“ï¼Œè¿™å–å†³äºæˆ‘ä»¬æƒ³è¦è§‚å¯Ÿä»€ä¹ˆã€‚åœ¨æœ¬ä¾‹ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨DispatchSourceFileSystemObjectï¼Œå®ƒå…è®¸æˆ‘ä»¬è§‚å¯Ÿæ¥è‡ªæ–‡ä»¶ç³»ç»Ÿçš„äº‹ä»¶ã€‚</p>
<p>è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªç®€å•FileObserverçš„ç¤ºä¾‹å®ç°ï¼Œå®ƒå…è®¸æˆ‘ä»¬é™„åŠ ä¸€ä¸ªé—­åŒ…ï¼Œä»¥ä¾¿åœ¨æ¯æ¬¡ç»™å®šæ–‡ä»¶å‘ç”Ÿæ›´æ”¹æ—¶è¿è¡Œã€‚å®ƒçš„å·¥ä½œåŸç†æ˜¯ä½¿ç”¨æ–‡ä»¶æè¿°ç¬¦å’ŒDispatchQueueåˆ›å»ºä¸€ä¸ªdispatch sourceæ¥æ‰§è¡Œè§‚å¯Ÿï¼Œå¹¶ä½¿ç”¨æ–‡ä»¶æ¥å¼•ç”¨è¦è§‚å¯Ÿçš„æ–‡ä»¶:</p>
<pre><code class="language-swift">class FileObserver {
    private let file: File
    private let queue: DispatchQueue
    private var source: DispatchSourceFileSystemObject?

    init(file: File) {
        self.file = file
        self.queue = DispatchQueue(label: &quot;com.myapp.fileObserving&quot;)
    }

    func start(closure: @escaping () -&gt; Void) {
        // We can only convert an NSString into a file system representation
        let path = (file.path as NSString)
        let fileSystemRepresentation = path.fileSystemRepresentation

        // Obtain a descriptor from the file system
        let fileDescriptor = open(fileSystemRepresentation, O_EVTONLY)

        // Create our dispatch source
        let source = DispatchSource.makeFileSystemObjectSource(
            fileDescriptor: fileDescriptor,
            eventMask: .write,
            queue: queue
        )

        // Assign the closure to it, and resume it to start observing
        source.setEventHandler(handler: closure)
        source.resume()
        self.source = source
    }
}
</code></pre>
<p>æˆ‘ä»¬ç°åœ¨å¯ä»¥åƒè¿™æ ·ä½¿ç”¨FileObserver:</p>
<pre><code class="language-swift">let observer = try FileObserver(file: file)

observer.start {
    print(&quot;File was changed&quot;)
}
</code></pre>
<p>æƒ³è±¡ä¸€ä¸‹ï¼Œæ‰€æœ‰å¾ˆé…·çš„å¼€å‘å·¥å…·éƒ½å¯ä»¥ç”¨å®ƒæ¥æ„å»º!ğŸ˜€</p>
<h2 id="conclusion">Conclusion</h2>
<p>Grand Central Dispatchæ˜¯ä¸€ä¸ªéå¸¸å¼ºå¤§çš„æ¡†æ¶ï¼Œå®ƒçš„åŠŸèƒ½è¿œè¿œè¶…è¿‡äº†å®ƒæœ€åˆçœ‹èµ·æ¥çš„æ ·å­ã€‚å¸Œæœ›è¿™ç¯‡æ–‡ç« èƒ½æ¿€å‘ä½ çš„æƒ³è±¡åŠ›ï¼Œè®©ä½ çŸ¥é“ä½ å¯ä»¥ç”¨å®ƒæ¥åšä»€ä¹ˆï¼Œæˆ‘å»ºè®®ä½ ä¸‹æ¬¡éœ€è¦åšæˆ‘ä»¬åœ¨è¿™ç¯‡æ–‡ç« ä¸­æåˆ°çš„ä»»åŠ¡æ—¶å°è¯•ä¸€ä¸‹ã€‚</p>
<p>åœ¨æˆ‘çœ‹æ¥ï¼Œå¾ˆå¤šåŸºäºè®¡æ—¶å™¨æˆ–æ“ä½œé˜Ÿåˆ—çš„ä»£ç ï¼Œä»¥åŠç¬¬ä¸‰æ–¹å¼‚æ­¥æ¡†æ¶çš„ä½¿ç”¨ï¼Œå®é™…ä¸Šå¯ä»¥é€šè¿‡ç›´æ¥ä½¿ç”¨GCDæ¥ç®€åŒ–ã€‚</p>
<p><a href="https://www.swiftbysundell.com/articles/a-deep-dive-into-grand-central-dispatch-in-swift/">åŸæ–‡é“¾æ¥</a></p>

            </div>
            
              <div class="tag-container">
                
                  <a href="http://localhost:4000/tag/ArhVOQ_GL/" class="tag">
                    concurrency
                  </a>
                
                  <a href="http://localhost:4000/tag/C46TKgaZSw/" class="tag">
                    GCD
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">ä¸‹ä¸€ç¯‡</div>
                <a href="http://localhost:4000/post/using-autoclosure-when-designing-swift-apis/">
                  <h3 class="post-title">
                    Using @autoclosure when designing Swift APIs
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.6.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
