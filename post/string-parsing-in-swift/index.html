<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>String parsing in Swift | Kayouyou&#39;s Den</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://kayouyou.github.io/favicon.ico?v=1665922595647">
<link rel="stylesheet" href="https://kayouyou.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="å‡ ä¹åœ°çƒä¸Šçš„æ¯ä¸ªç¨‹åºéƒ½å¿…é¡»ä»¥è¿™æ ·æˆ–é‚£æ ·çš„æ–¹å¼å¤„ç†å­—ç¬¦ä¸²ï¼Œå› ä¸ºæ–‡æœ¬å¯¹äºæˆ‘ä»¬å¦‚ä½•é€šä¿¡å’Œè¡¨ç¤ºå„ç§å½¢å¼çš„æ•°æ®æ˜¯å¦‚æ­¤é‡è¦ã€‚ä½†æ˜¯ï¼Œä»¥ä¸€ç§æ—¢å¥å£®åˆé«˜æ•ˆçš„æ–¹å¼å¤„ç†å’Œè§£æå­—ç¬¦ä¸²æœ‰æ—¶ä¼šéå¸¸å›°éš¾ã€‚è™½ç„¶æœ‰äº›å­—ç¬¦ä¸²ä»¥éå¸¸ä¸¥æ ¼å’Œè®¡ç®—æœºå‹å¥½çš„æ ¼å¼å‡ºç°ï¼Œå¦‚JSONæˆ–XML..." />
    <meta name="keywords" content="parsing,algorithms,strings" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://kayouyou.github.io">
        <img src="https://kayouyou.github.io/images/avatar.png?v=1665922595647" class="site-logo">
        <h1 class="site-title">Kayouyou&#39;s Den</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            é¦–é¡µ
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            å½’æ¡£
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            æ ‡ç­¾
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            å…³äº
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      The wise build bridges, while the foolish build barriers.
    </div>
    <div class="site-footer">
       <a href="https://beian.miit.gov.cn/">è±«ICPå¤‡2021012281å·-1</a> | <a class="rss" href="https://kayouyou.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">String parsing in Swift</h2>
            <div class="post-date">2019-03-17</div>
            
            <div class="post-content" v-pre>
              <p>å‡ ä¹åœ°çƒä¸Šçš„æ¯ä¸ªç¨‹åºéƒ½å¿…é¡»ä»¥è¿™æ ·æˆ–é‚£æ ·çš„æ–¹å¼å¤„ç†å­—ç¬¦ä¸²ï¼Œå› ä¸ºæ–‡æœ¬å¯¹äºæˆ‘ä»¬å¦‚ä½•é€šä¿¡å’Œè¡¨ç¤ºå„ç§å½¢å¼çš„æ•°æ®æ˜¯å¦‚æ­¤é‡è¦ã€‚ä½†æ˜¯ï¼Œä»¥ä¸€ç§æ—¢å¥å£®åˆé«˜æ•ˆçš„æ–¹å¼å¤„ç†å’Œè§£æå­—ç¬¦ä¸²æœ‰æ—¶ä¼šéå¸¸å›°éš¾ã€‚è™½ç„¶æœ‰äº›å­—ç¬¦ä¸²ä»¥éå¸¸ä¸¥æ ¼å’Œè®¡ç®—æœºå‹å¥½çš„æ ¼å¼å‡ºç°ï¼Œå¦‚JSONæˆ–XMLï¼Œä½†å…¶ä»–å­—ç¬¦ä¸²å¯èƒ½è¦æ··ä¹±å¾—å¤šã€‚</p>
<p>è¿™å‘¨ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹ä»è¿™äº›å­—ç¬¦ä¸²ä¸­è§£æå’Œæå–ä¿¡æ¯çš„å„ç§æ–¹æ³•ï¼Œä»¥åŠä¸åŒçš„æŠ€æœ¯å’Œapiå¦‚ä½•äº§ç”Ÿä¸åŒçš„æƒè¡¡ã€‚</p>
<h2 id="string-and-its-friends">String and its friends</h2>
<p>åœ¨æŸäº›æ–¹é¢ï¼ŒSwiftå› å…¶åœ¨å­—ç¬¦ä¸²è§£ææ–¹é¢æœ‰ç‚¹éš¾å¤„ç†è€Œå£°åé¹Šèµ·ã€‚è™½ç„¶Swiftçš„å­—ç¬¦ä¸²å®ç°å¹¶æ²¡æœ‰åƒå…¶ä»–è¯­è¨€é‚£æ ·æä¾›é‚£ä¹ˆå¤šçš„ä¾¿åˆ©(ä¾‹å¦‚ï¼Œä½ ä¸èƒ½ç®€å•åœ°ä½¿ç”¨æ•´æ•°è®¿é—®ç»™å®šçš„å­—ç¬¦ï¼Œæ¯”å¦‚å­—ç¬¦ä¸²[7])ï¼Œå®ƒç¡®å®ä½¿ç¼–å†™æ­£ç¡®çš„å­—ç¬¦ä¸²è§£æä»£ç å˜å¾—æ›´å®¹æ˜“ã€‚</p>
<p>å› ä¸ºå°½ç®¡èƒ½å¤Ÿæ ¹æ®æ„ŸçŸ¥åˆ°çš„ä½ç½®éšæœºè®¿é—®å­—ç¬¦ä¸²ä¸­çš„ä»»ä½•ç»™å®šå­—ç¬¦æ˜¯ä»¶å¥½äº‹ï¼Œä½†æˆ‘ä»¬ä»Šå¤©ç”Ÿæ´»çš„å¤šè¯­è¨€(æˆ–è€…å¯èƒ½æ˜¯è¡¨æƒ…ç¬¦å·è¯­è¨€?)çš„ä¸–ç•Œä½¿è¿™ç§apiéå¸¸å®¹æ˜“å‡ºé”™ï¼Œå› ä¸ºåœ¨å¾ˆå¤šæƒ…å†µä¸‹ï¼Œåœ¨æ–‡æœ¬UIä¸­è¡¨ç¤ºå­—ç¬¦çš„æ–¹å¼ä¸åœ¨å­—ç¬¦ä¸²å€¼ä¸­å­˜å‚¨å­—ç¬¦çš„æ–¹å¼éå¸¸ä¸åŒã€‚</p>
<p>åœ¨Swiftä¸­ï¼Œå­—ç¬¦ä¸²ç”±ä¸€ç»„ä½¿ç”¨UTF-8ç¼–ç å­˜å‚¨çš„å­—ç¬¦å€¼ç»„æˆã€‚ è¿™æ„å‘³ç€å¦‚æœæˆ‘ä»¬éå†ä¸€ä¸ªå­—ç¬¦ä¸²(ä¾‹å¦‚ä½¿ç”¨forå¾ªç¯)ï¼Œæ¯ä¸ªå…ƒç´ éƒ½å°†æ˜¯ä¸€ä¸ªå­—ç¬¦â€”â€”å¯èƒ½æ˜¯ä¸€ä¸ªå­—æ¯ã€ä¸€ä¸ªè¡¨æƒ…ç¬¦å·æˆ–å…¶ä»–å½¢å¼çš„å­—ç¬¦ã€‚è¦è¯†åˆ«ä¸€ç»„å­—ç¬¦(å¦‚å­—æ¯æˆ–æ•°å­—)ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å­—ç¬¦é›†ï¼Œå®ƒå¯ä»¥ä¼ é€’ç»™å…³äºå­—ç¬¦ä¸²åŠå…¶ç›¸å…³ç±»å‹çš„å‡ ä¸ªä¸åŒçš„apiã€‚</p>
<h2 id="tokenizing-usernames">Tokenizing usernames</h2>
<p>å‡è®¾æˆ‘ä»¬æ­£åœ¨å¼€å‘ä¸€ä¸ªåº”ç”¨ç¨‹åºï¼Œè®©å‡ ä¸ªä¸åŒçš„ç”¨æˆ·åœ¨ä¸€ä¸ªæ–‡æ¡£ä¸Šåä½œï¼Œæˆ‘ä»¬æƒ³å®ç°ä¸€ä¸ªåŠŸèƒ½ï¼Œè®©ç”¨æˆ·ä½¿ç”¨ç±»ä¼¼twitterçš„@mentionè¯­æ³•æ¥æåŠå…¶ä»–äººã€‚</p>
<p>è¯†åˆ«ç»™å®šå­—ç¬¦ä¸²ä¸­æåˆ°çš„ç”¨æˆ·å®é™…ä¸Šä¸Swiftç¼–è¯‘å™¨åœ¨è¯†åˆ«ä»£ç å­—ç¬¦ä¸²ä¸­çš„ä¸åŒéƒ¨åˆ†æ—¶æ‰€éœ€è¦åšçš„å·¥ä½œéå¸¸ç›¸ä¼¼ â€”ç§°ä¸ºè¯æ³•åˆ†ææˆ–æ ‡è®°åŒ–çš„è¿‡ç¨‹â€”åªæ˜¯æˆ‘ä»¬çš„å®ç°è¦ç®€å•å‡ ä¸ªæ•°é‡çº§ï¼Œå› ä¸ºæˆ‘ä»¬åªéœ€è¦å¯»æ‰¾ä¸€ç§æ ‡è®°ã€‚</p>
<p>åˆå§‹å®ç°å¯èƒ½æ˜¯è¿™æ ·çš„â€”â€”Stringä¸Šçš„ä¸€ä¸ªè®¡ç®—å±æ€§ï¼Œåœ¨è¿™ä¸ªå±æ€§ä¸­ï¼Œæˆ‘ä»¬æ ¹æ®@å­—ç¬¦åˆ†å‰²å­—ç¬¦ä¸²ï¼Œåˆ é™¤ç¬¬ä¸€ä¸ªå…ƒç´ (å› ä¸ºå®ƒå°†æ˜¯ç¬¬ä¸€ä¸ª@-ç¬¦å·ä¹‹å‰çš„æ–‡æœ¬)ï¼Œç„¶åå¯¹ç»“æœè¿›è¡ŒcompactMapâ€”â€” è¯†åˆ«éç©ºçš„çº¯å­—æ¯å­—ç¬¦å­—ç¬¦ä¸²ï¼š</p>
<pre><code class="language-swift">extension String {
    var mentionedUsernames: [String] {
        let parts = split(separator: &quot;@&quot;).dropFirst()

        // Character sets may be inverted to identify all
        // characters that are *not* a member of the set.
        let delimiterSet = CharacterSet.letters.inverted

        return parts.compactMap { part in
            // Here we grab the first sequence of letters right
            // after the @-sign, and check that itâ€™s non-empty.
            let name = part.components(separatedBy: delimiterSet)[0]
            return name.isEmpty ? nil : name
        }
    }
}
</code></pre>
<p>ä¸Šé¢çš„å®ç°éå¸¸ç®€å•ï¼Œå¹¶ä¸”ä½¿ç”¨äº†ä¸€äº›éå¸¸å¥½çš„Swiftç‰¹æ€§â€”â€”æ¯”å¦‚ä¿®æ”¹é›†åˆï¼Œä½¿ç”¨compactMapä¸¢å¼ƒnilå€¼ï¼Œç­‰ç­‰ã€‚ä½†å®ƒç¡®å®æœ‰ä¸€ä¸ªé—®é¢˜â€”â€”å®ƒéœ€è¦ä¸‰æ¬¡è¿­ä»£ï¼Œä¸€æ¬¡åŸºäº@å­—ç¬¦åˆ†å‰²å­—ç¬¦ä¸²ï¼Œä¸€æ¬¡éå†æ‰€æœ‰è¿™äº›éƒ¨åˆ†ï¼Œç„¶åä¸€æ¬¡åŸºäºéå­—æ¯å­—ç¬¦åˆ†å‰²æ¯ä¸ªéƒ¨åˆ†ã€‚</p>
<p>è™½ç„¶æ¯æ¬¡è¿­ä»£éƒ½å°äºå‰ä¸€æ¬¡è¿­ä»£(æ‰€ä»¥æˆ‘ä»¬çš„ç®—æ³•çš„å¤æ‚åº¦ä¸æ˜¯O(3N))ï¼Œ éšç€è¾“å…¥æ•°æ®é›†çš„å¢é•¿ï¼Œå¤šæ¬¡è¿­ä»£é€šå¸¸ä¼šå¯¼è‡´æŸç§å½¢å¼çš„ç“¶é¢ˆã€‚ è¿™åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­å¯èƒ½æˆä¸ºä¸€ä¸ªé—®é¢˜ï¼Œå› ä¸ºæˆ‘ä»¬æ­£è®¡åˆ’å°†æ­¤ç®—æ³•åº”ç”¨äºä»»ä½•å¤§å°çš„æ–‡æ¡£(ä¹Ÿè®¸æœ‰äº›ç”¨æˆ·ä¼šç”¨æˆ‘ä»¬çš„åº”ç”¨ä¸€èµ·å†™ä¸€æœ¬ä¹¦ï¼Œè°çŸ¥é“å‘¢?)æˆ‘ä»¬æ¥çœ‹çœ‹èƒ½ä¸èƒ½åšç‚¹ä»€ä¹ˆæ¥ä¼˜åŒ–å®ƒã€‚</p>
<p>ä¸å…¶å°†å­—ç¬¦ä¸²åˆ†å‰²æˆç»„ä»¶ï¼Œç„¶åéå†è¿™äº›ç»„ä»¶ï¼Œä¸å¦‚é€šè¿‡éå†å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦æ¥è¿›è¡Œä¸€æ¬¡éå†ã€‚ è™½ç„¶è¿™éœ€è¦æ›´å¤šçš„æ‰‹åŠ¨è§£æä»£ç ï¼Œä½†å®ƒå°†ä½¿æˆ‘ä»¬èƒ½å¤Ÿå°†ç®—æ³•ç®€åŒ–ä¸ºä¸€æ¬¡è¿­ä»£â€”â€”åƒè¿™æ ·:</p>
<pre><code class="language-swift">extension String {
    var mentionedUsernames: [String] {
        // Setting up our state, which is any partial name that weâ€™re
        // currently parsing, and an array of all names found.
        var partialName: String?
        var names = [String]()

        // A nested parsing function, that weâ€™ll apply to each
        // character within the string.
        func parse(_ character: Character) {
            if var name = partialName {
                guard character.isLetter else {
                    // If we encounter a non-letter character
                    // while parsing a name, it means that the
                    // name is finished, and we can add it to
                    // our array (if non-empty):
                    if !name.isEmpty {
                        names.append(name)
                    }

                    // Reset our state, and parse the character
                    // again, since it might be an @-sign.
                    partialName = nil
                    return parse(character)
                }

                name.append(character)
                partialName = name
            } else if character == &quot;@&quot; {
                // Set an empty state, to signal to our above
                // code that itâ€™s time to start parsing a name.
                partialName = &quot;&quot;
            }
        }

        // Apply our parsing function to each character
        forEach(parse)

        // Once weâ€™ve reached the end, weâ€™ll make sure to
        // capture any name that was previously found.
        if let lastName = partialName, !lastName.isEmpty {
            names.append(lastName)
        }

        return names
    }
}
</code></pre>
<p>æ³¨æ„ï¼Œä¸Šé¢çš„isLetter APIæ˜¯åœ¨Swift 5ä¸­æ·»åŠ çš„ã€‚</p>
<p>è™½ç„¶ä¸Šé¢çš„å®ç°æ¯”æˆ‘ä»¬æœ€åˆçš„è¦å¤æ‚å¾—å¤šâ€”â€”å®ƒçš„é€Ÿåº¦(å¹³å‡)æ˜¯åŸæ¥çš„ä¸¤å€ï¼Œè¿™ç»™äº†æˆ‘ä»¬ç¬¬ä¸€ä¸ªæ˜ç¡®çš„æƒè¡¡: æˆ‘ä»¬æ˜¯é€‰æ‹©ä»¥æ½œåœ¨çš„æ€§èƒ½æˆæœ¬ä¸ºä»£ä»·çš„æ›´ç®€å•çš„è§£å†³æ–¹æ¡ˆï¼Œè¿˜æ˜¯é€‰æ‹©ç»´æŠ¤ä¸€ä¸ªæ›´å¤æ‚ã€æ›´é«˜æ•ˆçš„ç®—æ³•?</p>
<h2 id="detecting-multiple-tokens">Detecting multiple tokens</h2>
<p>éšç€éœ€æ±‚åˆ—è¡¨çš„å¢é•¿ï¼Œè®¨è®ºæ¥å—å“ªä¸€ç§å–èˆå˜å¾—æ›´åŠ æœ‰è¶£ã€‚å‡è®¾åœ¨æˆåŠŸåœ°å‘ç”¨æˆ·æ¨å‡ºäº†æåŠåŠŸèƒ½åï¼Œæˆ‘ä»¬å¼€å§‹æ”¶åˆ°æ·»åŠ å¯¹æ ‡ç­¾æ”¯æŒçš„è¯·æ±‚ï¼Œæˆ‘ä»¬å†³å®šè¿™æ ·åšã€‚</p>
<p>å› ä¸ºæ£€æµ‹ç”¨æˆ·åå’Œæ ‡ç­¾æ˜¯å®Œå…¨ç›¸åŒçš„é—®é¢˜(åªæ˜¯å¼€å¤´å­—ç¬¦ä¸åŒ- @ vs #)ï¼Œä½¿ç”¨ç›¸åŒçš„å®ç°æ¥æ£€æµ‹ä¸¤è€…æ˜¯æœ‰æ„ä¹‰çš„ã€‚ä¸ºäº†å®ç°è¿™ä¸€ç‚¹ï¼Œè®©æˆ‘ä»¬é¦–å…ˆå®šä¹‰ä¸€ä¸ªç¬¦å·ç±»å‹ï¼Œæˆ‘ä»¬å°†ç”¨å®ƒæ¥è¡¨ç¤ºä¸€ä¸ªæåŠæˆ–ä¸€ä¸ªæ ‡ç­¾:</p>
<pre><code class="language-swift">struct Symbol {
    enum Kind { case mention, hashtag }

    let kind: Kind
    var string: String
}
</code></pre>
<p>è€Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¸¦æœ‰å…³è”å­—ç¬¦ä¸²å€¼çš„æšä¸¾ä»£æ›¿ -ç”±äºæåˆ°å’Œæ ‡ç­¾å…±äº«ç›¸åŒçš„ç»“æ„ï¼Œä½¿ç”¨ç»“æ„ä¼šä½¿æˆ‘ä»¬çš„ç®—æ³•æ›´ç®€å•ä¸€äº›ã€‚ ç„¶è€Œï¼Œä¸ºäº†ä½¿Symbolèƒ½å¤Ÿä»¥ç±»ä¼¼æšä¸¾çš„æ–¹å¼ä½¿ç”¨ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥æ·»åŠ ä¸€äº›é™æ€å·¥å‚æ–¹æ³•ï¼Œä½¿ä½¿ç”¨ç‚¹è¯­æ³•æ„é€ å€¼å˜å¾—æ›´å®¹æ˜“:</p>
<pre><code class="language-swift">extension Symbol {
    static func mention(_ string: String) -&gt; Symbol {
        return Symbol(kind: .mention, string: string)
    }

    static func hashtag(_ string: String) -&gt; Symbol {
        return Symbol(kind: .hashtag, string: string)
    }
}
</code></pre>
<p>æœ‰äº†ä¸Šé¢çš„å†…å®¹ï¼Œç°åœ¨è®©æˆ‘ä»¬æ›´æ–°ä¹‹å‰æåˆ°çš„usernamesç®—æ³•æ¥æ£€æµ‹ç¬¦å·ï¼Œè€Œä¸ä»…ä»…æ˜¯ç”¨æˆ·å:</p>
<pre><code class="language-swift">extension String {
    var symbols: [Symbol] {
        var partialSymbol: Symbol?
        var symbols = [Symbol]()

        func parse(_ character: Character) {
            if var symbol = partialSymbol {
                guard character.isLetter else {
                    if !symbol.string.isEmpty {
                        symbols.append(symbol)
                    }

                    partialSymbol = nil
                    return parse(character)
                }

                symbol.string.append(character)
                partialSymbol = symbol
            } else {
                // Hereâ€™s the only real difference compared to
                // the previous version, since weâ€™ll now decide
                // what kind of symbol weâ€™re parsing based on
                // its leading character:
                switch character {
                case &quot;@&quot;:
                    partialSymbol = .mention(&quot;&quot;)
                case &quot;#&quot;:
                    partialSymbol = .hashtag(&quot;&quot;)
                default:
                    break
                }
            }
        }

        forEach(parse)

        if let lastSymbol = partialSymbol, !lastSymbol.string.isEmpty {
            symbols.append(lastSymbol)
        }

        return symbols
    }
}
</code></pre>
<p>é€šè¿‡ä¸Šé¢çš„æ”¹å˜ï¼Œæˆ‘ä»¬æœ€åˆåŸºäºå­—ç¬¦ä¸²åˆ†å‰²çš„å®ç°å’Œæˆ‘ä»¬æœ€æ–°ç®—æ³•ä¹‹é—´çš„å·®å¼‚å˜å¾—æ›´å¤§äº†â€”â€”å› ä¸ºå¦‚æœæˆ‘ä»¬é€šè¿‡åˆ†å‰²å­—ç¬¦ä¸²æ¥æ ‡è®°ç”¨æˆ·åå’Œæ ‡ç­¾ï¼Œæˆ‘ä»¬éœ€è¦6ä¸ªä¸åŒçš„è¿­ä»£(2å€3) -ä¸¤ä¸ªå®Œæ•´çš„å­—ç¬¦ä¸²å°†é€šè¿‡åŸå§‹å­—ç¬¦ä¸²ã€‚</p>
<p>ç„¶è€Œï¼Œå¦‚æœæˆ‘ä»¬èƒ½åœ¨åˆå§‹å®ç°çš„ç®€å•æ€§å’Œæ‰‹åŠ¨ç®—æ³•çš„å¼ºå¤§æ€§ä¹‹é—´æ‰¾åˆ°æŸç§ä¸­é—´åœ°å¸¦ï¼Œé‚£å°±å¤ªå¥½äº†ã€‚ä¸€ç§æ–¹æ³•æ˜¯å¼•å…¥ä¸€ç§æŠ½è±¡ï¼Œå°†ç®—æ³•çš„æ ‡è®°åŒ–éƒ¨åˆ†ä¸å®é™…å¤„ç†ä»»ä½•å‘ç°çš„æ ‡è®°çš„é€»è¾‘åˆ†å¼€ã€‚</p>
<p>ä¸ºäº†åšåˆ°è¿™ä¸€ç‚¹ï¼Œè®©æˆ‘ä»¬å°†æœ€æ–°ç®—æ³•çš„å¤§éƒ¨åˆ†ç§»åŠ¨åˆ°ä¸€ä¸ªtokenizeæ–¹æ³•ä¸­ï¼Œè¯¥æ–¹æ³•æ¥å—ä¸€ä¸ªå¤„ç†ç¨‹åºçš„å­—å…¸ï¼ŒåŸºäºå®ƒä»¬å¤„ç†çš„å­—ç¬¦è¿›è¡Œæ•£åˆ—â€”â€”åƒè¿™æ ·:</p>
<pre><code class="language-swift">xtension String {
    func tokenize(using handlers: [Character : (String) -&gt; Void]) {
        // We no longer have to maintain an array of symbols,
        // but we do need to keep track of both any currently
        // parsed symbol, as well as which handler its for.
        var parsingData: (symbol: String, handler: (String) -&gt; Void)?

        func parse(_ character: Character) {
            if var data = parsingData {
                guard character.isLetter else {
                    if !data.symbol.isEmpty {
                        data.handler(data.symbol)
                    }

                    parsingData = nil
                    return parse(character)
                }

                data.symbol.append(character)
                parsingData = data
            } else {
                // If we have a handler for a given character,
                // then weâ€™ll parse it.
                guard let handler = handlers[character] else {
                    return
                }

                parsingData = (&quot;&quot;, handler)
            }
        }

        forEach(parse)

        if let lastData = parsingData, !lastData.symbol.isEmpty {
            lastData.handler(lastData.symbol)
        }
    }
}
</code></pre>
<p>ä¸Šé¢çš„æ–¹æ³•ä¸ä»…ä½¿æˆ‘ä»¬çš„å®ç°æ›´æ¸…æ™°ï¼Œè€Œä¸”ç»™äº†æˆ‘ä»¬æ›´å¤šçš„çµæ´»æ€§ - å› ä¸ºæˆ‘ä»¬ç°åœ¨å¯ä»¥åœ¨è®¸å¤šä¸åŒçš„ä¸Šä¸‹æ–‡ä¸­é‡ç”¨ç›¸åŒçš„æ ‡è®°åŒ–ç®—æ³•ï¼Œå¹¶é€‰æ‹©æ¯ä¸ªæ ‡è®°åº”è¯¥å¦‚ä½•åœ¨è°ƒç”¨ç«™ç‚¹å¤„ç†ã€‚</p>
<p>æˆ‘ä»¬ç°åœ¨å¯ä»¥å‡å°‘æˆ‘ä»¬çš„ç¬¦å·è§£æä»£ç ï¼Œä»ä»¥å‰åˆ°ç°åœ¨:</p>
<pre><code class="language-swift">extension String {
    var symbols: [Symbol] {
        var symbols = [Symbol]()

        tokenize(using: [
            &quot;@&quot;: { symbols.append(.mention($0)) },
            &quot;#&quot;: { symbols.append(.hashtag($0)) }
        ])

        return symbols
    }
}
</code></pre>
<p>éå¸¸æ¼‚äº®å’Œå¹²å‡€!ğŸ‘ä½†æ˜¯ï¼Œå°±åƒä»¥å‰ä¸€æ ·ï¼Œè¿™æ¶‰åŠåˆ°ä¸€ç³»åˆ—çš„æƒè¡¡ã€‚ è™½ç„¶æŠ½è±¡æ˜¯ä¸€ç§å°†å¤æ‚é€»è¾‘éšè—åœ¨æ›´å¥½çš„APIèƒŒåçš„å¥½æ–¹æ³•â€”â€”ä½†å®ƒä»¬å¹¶ä¸æ˜¯å…è´¹çš„ã€‚äº‹å®ä¸Šï¼Œä¸å°†ç®—æ³•å†…è”åˆ°symbolså±æ€§æ—¶ç›¸æ¯”ï¼Œæˆ‘ä»¬çš„æœ€æ–°ç‰ˆæœ¬éœ€è¦æ›´å¤š40%çš„æ—¶é—´æ¥è¿è¡Œã€‚ç„¶è€Œï¼Œå®ƒä»ç„¶æ˜¯ç”¨åˆ†è£‚å­—ç¬¦ä¸²æ¥åšåŒæ ·äº‹æƒ…çš„ä¸¤å€ï¼Œæ‰€ä»¥å®ƒå¯èƒ½æ˜¯æˆ‘ä»¬æƒ³è¦çš„ä¸­é—´ä½ç½®ã€‚</p>
<h2 id="scanning-for-tokens">Scanning for tokens</h2>
<p>åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬ä¸»è¦æ¯”è¾ƒçš„æ˜¯æ‰‹åŠ¨éå†å­—ç¬¦ä¸²çš„å­—ç¬¦å’Œå°†å…¶æ‹†åˆ†ä¸ºç»„ä»¶â€”â€”ä½†æ˜¯ï¼Œå°±åƒè®¸å¤šå…¶ä»–äº‹æƒ…ä¸€æ ·ï¼Œè¿˜æœ‰æ›´å¤šçš„é€‰é¡¹éœ€è¦è€ƒè™‘ã€‚</p>
<p>å…¶ä¸­ä¸€ä¸ªé€‰é¡¹æ˜¯ä½¿ç”¨Foundationçš„æ‰«æå™¨ç±»å‹æ¥æŒç»­æ‰«æå­—ç¬¦ä¸²ï¼Œä»¥è¯†åˆ«æˆ‘ä»¬æ­£åœ¨å¯»æ‰¾çš„ä»¤ç‰Œã€‚ å°±åƒæˆ‘ä»¬ä¹‹å‰çš„æœ€åä¸€ä¸ªå®ç°ä¸€æ ·ï¼Œå®ƒè®©æˆ‘ä»¬èƒ½å¤Ÿä¾é æŠ½è±¡(è¿™ä¸€æ¬¡æ˜¯è‹¹æœæä¾›çš„)æ¥å¤„ç†æˆ‘ä»¬ç®—æ³•çš„å¤§éƒ¨åˆ†â€œç¹é‡å·¥ä½œâ€ã€‚è¿™æ ·çš„å®ç°åº”è¯¥æ˜¯è¿™æ ·çš„:</p>
<pre><code class="language-swift">extension String {
    var symbols: [Symbol] {
        let scanner = Scanner(string: self)
        let symbolSet = CharacterSet(charactersIn: &quot;@#&quot;)
        var symbols = [Symbol]()
        var symbolKind: Symbol.Kind?

        // Scanner doesnâ€™t expose a sequence-like API, but rather
        // requires us to inspect its current state to decide
        // when the iteration is over.
        while !scanner.isAtEnd {
            if let kind = symbolKind {
                symbolKind = nil

                // Since Scanner is actually just a Swift interface
                // to the NSScanner Objective-C class, it requires
                // us to pass it an NSString pointer, which itâ€™ll
                // write the result into.
                var result: NSString?
                scanner.scanCharacters(from: .letters, into: &amp;result)

                guard let string = result else {
                    continue
                }

                symbols.append(Symbol(kind: kind, string: string as String))
            } else {
                // Here we scan until weâ€™ve found either an @ or
                // a # character, and then consume that character
                // while assigning a symbol kind to parse.
                scanner.scanUpToCharacters(from: symbolSet, into: nil)

                if scanner.scanString(&quot;@&quot;, into: nil) {
                    symbolKind = .mention
                } else if scanner.scanString(&quot;#&quot;, into: nil) {
                    symbolKind = .hashtag
                }
            }
        }

        return symbols
    }
}
</code></pre>
<p>ç„¶Scannerçš„â€œObjective-C-nessâ€å¯èƒ½ä¼šè®©æˆ‘ä»¬çš„ä»£ç çœ‹èµ·æ¥ä¸é‚£ä¹ˆâ€œæ•æ·â€ï¼Œä½†å¯¹äºè¿™ç±»é—®é¢˜ï¼Œå®ƒæ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„é€‰é¡¹-å®ƒçš„æ€§èƒ½ç‰¹å¾ä¸æˆ‘ä»¬ä¹‹å‰çš„åŸºäºè¿­ä»£çš„æ‰‹å·¥å®ç°ä¸ç›¸ä¸Šä¸‹ã€‚ä¹Ÿå¯ä»¥è®¤ä¸ºï¼Œä½¿ç”¨Scannerç”Ÿæˆçš„ä»£ç å¯è¯»æ€§ç¨å¾®å¼ºä¸€äº›ï¼Œå› ä¸ºå®ƒçš„apiæ˜¾å¼åœ°å£°æ˜ï¼Œæˆ‘ä»¬æ­£åœ¨æ‰«æç®—æ³•çš„æ¯ä¸ªéƒ¨åˆ†ä¸­çš„ç»™å®šå­—ç¬¦ä¸²ï¼Œä½†è¿™æ˜¯éå¸¸ä¸»è§‚çš„ã€‚</p>
<h2 id="the-art-of-being-lazy">The art of being lazy</h2>
<p>è®©æˆ‘ä»¬çœ‹ä¸€çœ‹ä¼˜åŒ–çš„æœ€åä¸€ç§æ–¹å¼â€”â€”ä½¿ç”¨æƒ°æ€§é›†åˆã€‚åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬æ‰€æ¢è®¨çš„æ‰€æœ‰å®ç°éƒ½æœ‰ä¸€ä¸ªå…±åŒç‚¹â€”â€”å®ƒä»¬éƒ½èƒ½ç«‹å³è§£ææ•´ä¸ªå­—ç¬¦ä¸²ã€‚è™½ç„¶è¿™å¯¹äºå°†ç«‹å³ä½¿ç”¨æ‰€æœ‰ç»“æœçš„ç”¨ä¾‹æ¥è¯´æ˜¯å®Œå…¨æ²¡é—®é¢˜çš„ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥é€šè¿‡ä»¥ä¸€ç§æ›´æ‡’æƒ°çš„æ–¹å¼æ‰§è¡Œè§£ææ¥æ½œåœ¨åœ°è¿›ä¸€æ­¥ä¼˜åŒ–ã€‚</p>
<p>å°±åƒæˆ‘ä»¬åœ¨â€œSwiftåºåˆ—:æ‡’æƒ°çš„è‰ºæœ¯â€ä¸­çœ‹åˆ°çš„é‚£æ ·ï¼Œå»¶è¿Ÿè®¡ç®—åºåˆ—ä¸­çš„ä¸€ä¸ªå…ƒç´ ï¼Œç›´åˆ°å®ƒçœŸæ­£éœ€è¦æ—¶ï¼Œæœ‰æ—¶å¯ä»¥æé«˜æˆ‘ä»¬çš„æ€§èƒ½â€”â€”å°¤å…¶æ˜¯å½“è°ƒç”¨è€…åªä½¿ç”¨æˆ‘ä»¬åºåˆ—çš„ä¸€ä¸ªå­é›†æ—¶ã€‚</p>
<p>è®©æˆ‘ä»¬å°†æœ€åä¸€ä¸ªåŸºäºæ‰«æå™¨çš„å®ç°æ›´æ–°ä¸ºå»¶è¿Ÿæ‰§è¡Œã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å°†ç®—æ³•å°è£…åœ¨AnySequenceå’ŒAnyIteratorä¸­ï¼Œè¿™ä½¿æˆ‘ä»¬èƒ½å¤Ÿå½¢æˆæƒ°æ€§åºåˆ—ï¼Œè€Œæ— éœ€ä»å¤´å®ç°ä¸€ä¸ªæ–°ç±»å‹:</p>
<pre><code class="language-swift">extension String {
    var symbols: AnySequence&lt;Symbol&gt; {
        // Since our character set is a constant, we can compute
        // it immediately, outside of our iteration closure.
        let symbolSet = CharacterSet(charactersIn: &quot;@#&quot;)

        // AnySequence enables us to use closures to define both
        // our sequence and its underlying iterator.
        return AnySequence&lt;Symbol&gt; { () -&gt; AnyIterator&lt;Symbol&gt; in
            let scanner = Scanner(string: self)
            var symbolKind: Symbol.Kind?

            // Weâ€™ve refactored our algorithm a bit to instead
            // use a nested function, that will be called by the
            // iterator to retrieve the next element (or nil, once
            // weâ€™ve reached the end of the sequence).
            func iterate() -&gt; Symbol? {
                guard !scanner.isAtEnd else {
                    return nil
                }

                guard let kind = symbolKind else {
                    scanner.scanUpToCharacters(from: symbolSet, into: nil)

                    if scanner.scanString(&quot;@&quot;, into: nil) {
                        symbolKind = .mention
                    } else if scanner.scanString(&quot;#&quot;, into: nil) {
                        symbolKind = .hashtag
                    }

                    return iterate()
                }

                symbolKind = nil

                var result: NSString?
                scanner.scanCharacters(from: .letters, into: &amp;result)

                guard let string = result else {
                    return iterate()
                }

                return Symbol(kind: kind, string: string as String)
            }

            return AnyIterator(iterate)
        }
    }
}
</code></pre>
<p>é€šè¿‡ä¸Šé¢çš„æ”¹å˜ï¼Œæˆ‘ä»¬ç°åœ¨å°†å¾—åˆ°ç›¸å½“æ˜¾è‘—çš„æ€§èƒ½æå‡çš„ä»£ç ï¼Œåƒè¿™æ ·çš„ä»£ç ï¼Œåªè¿­ä»£æˆ‘ä»¬çš„ç¬¦å·åºåˆ—ï¼Œç›´åˆ°ç»™å®šçš„ç‚¹:</p>
<pre><code class="language-swift">let firstHashtag = string.symbols.first { $0.kind == .hashtag }

</code></pre>
<p>è¿™å°±ä¸ºæˆ‘ä»¬å‘ˆç°äº†æœ¬æ–‡çš„æœ€ç»ˆå–èˆâ€”â€”æˆ‘ä»¬æ˜¯å¦æ„¿æ„æ¥å—é¢å¤–çš„ä¸€ç‚¹å¤æ‚æ€§(ä»¥åŠå¯èƒ½ç¨å¾®å›°éš¾ä¸€ç‚¹çš„è°ƒè¯•)ï¼Œä»¥ä½¿æ›´çŸ­çš„è¿­ä»£å…·æœ‰æ›´å¥½çš„æ€§èƒ½?</p>
<h2 id="conclusion">Conclusion</h2>
<p>å°±åƒåœ¨ç¼–å†™ä»»ä½•ä¸€ç§ç®—æ³•æ—¶ï¼Œåˆ°åº•å“ªç§å®ç°æœ€åˆé€‚ï¼Œå¾ˆå¤§ç¨‹åº¦ä¸Šå–å†³äºæˆ‘ä»¬è¦å¤„ç†çš„é—®é¢˜ç±»å‹ã€æˆ‘ä»¬è®¡åˆ’è¿è¡Œå®ƒçš„æ•°æ®é›†æœ‰å¤šå¤§ï¼Œä»¥åŠç»“æœå°†å¦‚ä½•è¢«ä½¿ç”¨ã€‚</p>
<p>å½“ç„¶ï¼Œè¿˜æœ‰è®¸å¤šæœ¬æ–‡æ²¡æœ‰ä»‹ç»çš„å…¶ä»–æ–¹æ³•æ¥è§£æSwiftä¸­çš„å­—ç¬¦ä¸²-ä¾‹å¦‚ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼ï¼Œæˆ–è€…æ·±å…¥åˆ°åº•å±‚Unicodeçº§åˆ«ä¸Šè§£æå†…å®¹-ä½†å¸Œæœ›å®ƒèƒ½è®©ä½ å¯¹æˆ‘ä»¬ä½¿ç”¨çš„ä¸€äº›å·¥å…·å’ŒæŠ€æœ¯æœ‰ä¸€ä¸ªæ¦‚è¿°ï¼Œä»¥åŠå„ç§å„æ ·çš„æƒè¡¡ã€‚</p>
<p>æˆ‘ä¸ªäººçš„æ–¹æ³•å‡ ä¹æ€»æ˜¯ä»æœ€ç®€å•çš„å®ç°å¼€å§‹ï¼ŒåŒæ—¶ä¸æ–­åœ°æµ‹é‡ç®—æ³•çš„ç»“æœå’Œæ€§èƒ½ç‰¹å¾ï¼Œæ ¹æ®éœ€è¦è¿›è¡Œæ‰©å±•â€”â€”å°±åƒæœ¬æ–‡ä¸­ä¸€æ ·ã€‚åœ¨ä¸‹ä¸€ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬è¿˜å°†æ›´ä»”ç»†åœ°ç ”ç©¶å¦‚ä½•æ ¹æ®å„ç§æ€§èƒ½æŒ‡æ ‡å‡†ç¡®åœ°åº¦é‡ä»£ç ã€‚</p>
<p><a href="https://www.swiftbysundell.com/articles/string-parsing-in-swift/">åŸæ–‡é“¾æ¥</a></p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://kayouyou.github.io/tag/jzAfftitH/" class="tag">
                    parsing
                  </a>
                
                  <a href="https://kayouyou.github.io/tag/qdJBgIYtC/" class="tag">
                    algorithms
                  </a>
                
                  <a href="https://kayouyou.github.io/tag/-e6COW1bj/" class="tag">
                    strings
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">ä¸‹ä¸€ç¯‡</div>
                <a href="https://kayouyou.github.io/post/error-handling/">
                  <h3 class="post-title">
                    Error Handling
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.6.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
